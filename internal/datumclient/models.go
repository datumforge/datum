// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package datumclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/datumforge/datum/internal/ent/generated/entitlement"
	"github.com/datumforge/datum/internal/ent/generated/groupsetting"
	"github.com/datumforge/datum/internal/ent/generated/session"
	"github.com/datumforge/datum/internal/ent/generated/usersetting"
)

// CreateEntitlementInput is used for create Entitlement object.
// Input was generated by ent.
type CreateEntitlementInput struct {
	CreatedAt *time.Time        `json:"createdAt,omitempty"`
	UpdatedAt *time.Time        `json:"updatedAt,omitempty"`
	CreatedBy *string           `json:"createdBy,omitempty"`
	UpdatedBy *string           `json:"updatedBy,omitempty"`
	Tier      *entitlement.Tier `json:"tier,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string    `json:"externalSubscriptionID,omitempty"`
	ExpiresAt              *time.Time `json:"expiresAt,omitempty"`
	UpgradedAt             *time.Time `json:"upgradedAt,omitempty"`
	// the tier the customer upgraded from
	UpgradedTier *string    `json:"upgradedTier,omitempty"`
	DowngradedAt *time.Time `json:"downgradedAt,omitempty"`
	// the tier the customer downgraded from
	DowngradedTier *string `json:"downgradedTier,omitempty"`
	Cancelled      *bool   `json:"cancelled,omitempty"`
	OwnerID        *string `json:"ownerID,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	Name        string     `json:"name"`
	Description *string    `json:"description,omitempty"`
	LogoURL     string     `json:"logoURL"`
	// The group's displayed 'friendly' name
	DisplayName *string  `json:"displayName,omitempty"`
	SettingID   string   `json:"settingID"`
	UserIDs     []string `json:"userIDs,omitempty"`
	OwnerID     string   `json:"ownerID"`
}

// CreateGroupSettingInput is used for create GroupSetting object.
// Input was generated by ent.
type CreateGroupSettingInput struct {
	CreatedAt  *time.Time               `json:"createdAt,omitempty"`
	UpdatedAt  *time.Time               `json:"updatedAt,omitempty"`
	CreatedBy  *string                  `json:"createdBy,omitempty"`
	UpdatedBy  *string                  `json:"updatedBy,omitempty"`
	Visibility *groupsetting.Visibility `json:"visibility,omitempty"`
	JoinPolicy *groupsetting.JoinPolicy `json:"joinPolicy,omitempty"`
	// tags associated with the object
	Tags         []string `json:"tags,omitempty"`
	SyncToSlack  *bool    `json:"syncToSlack,omitempty"`
	SyncToGithub *bool    `json:"syncToGithub,omitempty"`
	GroupID      *string  `json:"groupID,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	Name        string     `json:"name"`
	Kind        string     `json:"kind"`
	Description *string    `json:"description,omitempty"`
	SecretName  string     `json:"secretName"`
	OwnerID     *string    `json:"ownerID,omitempty"`
}

// CreateOauthProviderInput is used for create OauthProvider object.
// Input was generated by ent.
type CreateOauthProviderInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the provider's name
	Name string `json:"name"`
	// the client id
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle int64 `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string  `json:"infoURL"`
	OwnerID *string `json:"ownerID,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Name      string     `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description      *string  `json:"description,omitempty"`
	ParentID         *string  `json:"parentID,omitempty"`
	UserIDs          []string `json:"userIDs,omitempty"`
	GroupIDs         []string `json:"groupIDs,omitempty"`
	IntegrationIDs   []string `json:"integrationIDs,omitempty"`
	SettingID        *string  `json:"settingID,omitempty"`
	EntitlementIDs   []string `json:"entitlementIDs,omitempty"`
	OauthproviderIDs []string `json:"oauthproviderIDs,omitempty"`
}

// CreateOrganizationSettingInput is used for create OrganizationSetting object.
// Input was generated by ent.
type CreateOrganizationSettingInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains"`
	SsoCert       *string  `json:"ssoCert,omitempty"`
	SsoEntrypoint *string  `json:"ssoEntrypoint,omitempty"`
	SsoIssuer     *string  `json:"ssoIssuer,omitempty"`
	// Name of the person to contact for billing
	BillingContact string `json:"billingContact"`
	BillingEmail   string `json:"billingEmail"`
	BillingPhone   string `json:"billingPhone"`
	BillingAddress string `json:"billingAddress"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier string `json:"taxIdentifier"`
	// tags associated with the object
	Tags           []string `json:"tags,omitempty"`
	OrganizationID *string  `json:"organizationID,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
	UpdatedAt    *time.Time `json:"updatedAt,omitempty"`
	CreatedBy    *string    `json:"createdBy,omitempty"`
	UpdatedBy    *string    `json:"updatedBy,omitempty"`
	Name         string     `json:"name"`
	Token        *string    `json:"token,omitempty"`
	Abilities    []string   `json:"abilities,omitempty"`
	ExpirationAt time.Time  `json:"expirationAt"`
	Description  *string    `json:"description,omitempty"`
	LastUsedAt   *time.Time `json:"lastUsedAt,omitempty"`
	OwnerID      string     `json:"ownerID"`
}

// CreateRefreshTokenInput is used for create RefreshToken object.
// Input was generated by ent.
type CreateRefreshTokenInput struct {
	ClientID                string     `json:"clientID"`
	Scopes                  []string   `json:"scopes,omitempty"`
	Nonce                   string     `json:"nonce"`
	ClaimsUserID            string     `json:"claimsUserID"`
	ClaimsUsername          string     `json:"claimsUsername"`
	ClaimsEmail             string     `json:"claimsEmail"`
	ClaimsEmailVerified     bool       `json:"claimsEmailVerified"`
	ClaimsGroups            []string   `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string     `json:"claimsPreferredUsername"`
	ConnectorID             string     `json:"connectorID"`
	ConnectorData           []string   `json:"connectorData,omitempty"`
	Token                   string     `json:"token"`
	ObsoleteToken           string     `json:"obsoleteToken"`
	LastUsed                *time.Time `json:"lastUsed,omitempty"`
	UserID                  *string    `json:"userID,omitempty"`
}

// CreateSessionInput is used for create Session object.
// Input was generated by ent.
type CreateSessionInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token *string `json:"token,omitempty"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips     string  `json:"ips"`
	UsersID *string `json:"usersID,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Email     string     `json:"email"`
	FirstName string     `json:"firstName"`
	LastName  string     `json:"lastName"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user bcrypt password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// whether the user uses oauth for login or not
	Oauth                  *bool    `json:"oauth,omitempty"`
	OrganizationIDs        []string `json:"organizationIDs,omitempty"`
	SessionIDs             []string `json:"sessionIDs,omitempty"`
	GroupIDs               []string `json:"groupIDs,omitempty"`
	PersonalAccessTokenIDs []string `json:"personalAccessTokenIDs,omitempty"`
	SettingID              string   `json:"settingID"`
	RefreshtokenIDs        []string `json:"refreshtokenIDs,omitempty"`
}

// CreateUserSettingInput is used for create UserSetting object.
// Input was generated by ent.
type CreateUserSettingInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// local user password recovery code generated during account creation - does not exist for oauth'd users
	RecoveryCode   *string             `json:"recoveryCode,omitempty"`
	Status         *usersetting.Status `json:"status,omitempty"`
	Role           *usersetting.Role   `json:"role,omitempty"`
	Permissions    []string            `json:"permissions,omitempty"`
	EmailConfirmed *bool               `json:"emailConfirmed,omitempty"`
	// tags associated with the object
	Tags   []string `json:"tags,omitempty"`
	UserID *string  `json:"userID,omitempty"`
}

type Entitlement struct {
	ID        string           `json:"id"`
	CreatedAt time.Time        `json:"createdAt"`
	UpdatedAt time.Time        `json:"updatedAt"`
	CreatedBy *string          `json:"createdBy,omitempty"`
	UpdatedBy *string          `json:"updatedBy,omitempty"`
	Tier      entitlement.Tier `json:"tier"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string    `json:"externalSubscriptionID,omitempty"`
	ExpiresAt              *time.Time `json:"expiresAt,omitempty"`
	UpgradedAt             *time.Time `json:"upgradedAt,omitempty"`
	// the tier the customer upgraded from
	UpgradedTier *string    `json:"upgradedTier,omitempty"`
	DowngradedAt *time.Time `json:"downgradedAt,omitempty"`
	// the tier the customer downgraded from
	DowngradedTier *string       `json:"downgradedTier,omitempty"`
	Cancelled      bool          `json:"cancelled"`
	Owner          *Organization `json:"owner,omitempty"`
}

func (Entitlement) IsNode() {}

// A connection to a list of items.
type EntitlementConnection struct {
	// A list of edges.
	Edges []*EntitlementEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlement mutation
type EntitlementCreatePayload struct {
	// Created entitlement
	Entitlement Entitlement `json:"entitlement"`
}

// Return response for deleteEntitlement mutation
type EntitlementDeletePayload struct {
	// Deleted entitlement ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementEdge struct {
	// The item at the end of the edge.
	Node *Entitlement `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateEntitlement mutation
type EntitlementUpdatePayload struct {
	// Updated entitlement
	Entitlement Entitlement `json:"entitlement"`
}

// EntitlementWhereInput is used for filtering Entitlement objects.
// Input was generated by ent.
type EntitlementWhereInput struct {
	Not *EntitlementWhereInput   `json:"not,omitempty"`
	And []*EntitlementWhereInput `json:"and,omitempty"`
	Or  []*EntitlementWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// tier field predicates
	Tier      *entitlement.Tier  `json:"tier,omitempty"`
	TierNeq   *entitlement.Tier  `json:"tierNEQ,omitempty"`
	TierIn    []entitlement.Tier `json:"tierIn,omitempty"`
	TierNotIn []entitlement.Tier `json:"tierNotIn,omitempty"`
	// external_customer_id field predicates
	ExternalCustomerID             *string  `json:"externalCustomerID,omitempty"`
	ExternalCustomerIDNeq          *string  `json:"externalCustomerIDNEQ,omitempty"`
	ExternalCustomerIDIn           []string `json:"externalCustomerIDIn,omitempty"`
	ExternalCustomerIDNotIn        []string `json:"externalCustomerIDNotIn,omitempty"`
	ExternalCustomerIDGt           *string  `json:"externalCustomerIDGT,omitempty"`
	ExternalCustomerIDGte          *string  `json:"externalCustomerIDGTE,omitempty"`
	ExternalCustomerIDLt           *string  `json:"externalCustomerIDLT,omitempty"`
	ExternalCustomerIDLte          *string  `json:"externalCustomerIDLTE,omitempty"`
	ExternalCustomerIDContains     *string  `json:"externalCustomerIDContains,omitempty"`
	ExternalCustomerIDHasPrefix    *string  `json:"externalCustomerIDHasPrefix,omitempty"`
	ExternalCustomerIDHasSuffix    *string  `json:"externalCustomerIDHasSuffix,omitempty"`
	ExternalCustomerIDIsNil        *bool    `json:"externalCustomerIDIsNil,omitempty"`
	ExternalCustomerIDNotNil       *bool    `json:"externalCustomerIDNotNil,omitempty"`
	ExternalCustomerIDEqualFold    *string  `json:"externalCustomerIDEqualFold,omitempty"`
	ExternalCustomerIDContainsFold *string  `json:"externalCustomerIDContainsFold,omitempty"`
	// external_subscription_id field predicates
	ExternalSubscriptionID             *string  `json:"externalSubscriptionID,omitempty"`
	ExternalSubscriptionIDNeq          *string  `json:"externalSubscriptionIDNEQ,omitempty"`
	ExternalSubscriptionIDIn           []string `json:"externalSubscriptionIDIn,omitempty"`
	ExternalSubscriptionIDNotIn        []string `json:"externalSubscriptionIDNotIn,omitempty"`
	ExternalSubscriptionIDGt           *string  `json:"externalSubscriptionIDGT,omitempty"`
	ExternalSubscriptionIDGte          *string  `json:"externalSubscriptionIDGTE,omitempty"`
	ExternalSubscriptionIDLt           *string  `json:"externalSubscriptionIDLT,omitempty"`
	ExternalSubscriptionIDLte          *string  `json:"externalSubscriptionIDLTE,omitempty"`
	ExternalSubscriptionIDContains     *string  `json:"externalSubscriptionIDContains,omitempty"`
	ExternalSubscriptionIDHasPrefix    *string  `json:"externalSubscriptionIDHasPrefix,omitempty"`
	ExternalSubscriptionIDHasSuffix    *string  `json:"externalSubscriptionIDHasSuffix,omitempty"`
	ExternalSubscriptionIDIsNil        *bool    `json:"externalSubscriptionIDIsNil,omitempty"`
	ExternalSubscriptionIDNotNil       *bool    `json:"externalSubscriptionIDNotNil,omitempty"`
	ExternalSubscriptionIDEqualFold    *string  `json:"externalSubscriptionIDEqualFold,omitempty"`
	ExternalSubscriptionIDContainsFold *string  `json:"externalSubscriptionIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// upgraded_at field predicates
	UpgradedAt       *time.Time   `json:"upgradedAt,omitempty"`
	UpgradedAtNeq    *time.Time   `json:"upgradedAtNEQ,omitempty"`
	UpgradedAtIn     []*time.Time `json:"upgradedAtIn,omitempty"`
	UpgradedAtNotIn  []*time.Time `json:"upgradedAtNotIn,omitempty"`
	UpgradedAtGt     *time.Time   `json:"upgradedAtGT,omitempty"`
	UpgradedAtGte    *time.Time   `json:"upgradedAtGTE,omitempty"`
	UpgradedAtLt     *time.Time   `json:"upgradedAtLT,omitempty"`
	UpgradedAtLte    *time.Time   `json:"upgradedAtLTE,omitempty"`
	UpgradedAtIsNil  *bool        `json:"upgradedAtIsNil,omitempty"`
	UpgradedAtNotNil *bool        `json:"upgradedAtNotNil,omitempty"`
	// upgraded_tier field predicates
	UpgradedTier             *string  `json:"upgradedTier,omitempty"`
	UpgradedTierNeq          *string  `json:"upgradedTierNEQ,omitempty"`
	UpgradedTierIn           []string `json:"upgradedTierIn,omitempty"`
	UpgradedTierNotIn        []string `json:"upgradedTierNotIn,omitempty"`
	UpgradedTierGt           *string  `json:"upgradedTierGT,omitempty"`
	UpgradedTierGte          *string  `json:"upgradedTierGTE,omitempty"`
	UpgradedTierLt           *string  `json:"upgradedTierLT,omitempty"`
	UpgradedTierLte          *string  `json:"upgradedTierLTE,omitempty"`
	UpgradedTierContains     *string  `json:"upgradedTierContains,omitempty"`
	UpgradedTierHasPrefix    *string  `json:"upgradedTierHasPrefix,omitempty"`
	UpgradedTierHasSuffix    *string  `json:"upgradedTierHasSuffix,omitempty"`
	UpgradedTierIsNil        *bool    `json:"upgradedTierIsNil,omitempty"`
	UpgradedTierNotNil       *bool    `json:"upgradedTierNotNil,omitempty"`
	UpgradedTierEqualFold    *string  `json:"upgradedTierEqualFold,omitempty"`
	UpgradedTierContainsFold *string  `json:"upgradedTierContainsFold,omitempty"`
	// downgraded_at field predicates
	DowngradedAt       *time.Time   `json:"downgradedAt,omitempty"`
	DowngradedAtNeq    *time.Time   `json:"downgradedAtNEQ,omitempty"`
	DowngradedAtIn     []*time.Time `json:"downgradedAtIn,omitempty"`
	DowngradedAtNotIn  []*time.Time `json:"downgradedAtNotIn,omitempty"`
	DowngradedAtGt     *time.Time   `json:"downgradedAtGT,omitempty"`
	DowngradedAtGte    *time.Time   `json:"downgradedAtGTE,omitempty"`
	DowngradedAtLt     *time.Time   `json:"downgradedAtLT,omitempty"`
	DowngradedAtLte    *time.Time   `json:"downgradedAtLTE,omitempty"`
	DowngradedAtIsNil  *bool        `json:"downgradedAtIsNil,omitempty"`
	DowngradedAtNotNil *bool        `json:"downgradedAtNotNil,omitempty"`
	// downgraded_tier field predicates
	DowngradedTier             *string  `json:"downgradedTier,omitempty"`
	DowngradedTierNeq          *string  `json:"downgradedTierNEQ,omitempty"`
	DowngradedTierIn           []string `json:"downgradedTierIn,omitempty"`
	DowngradedTierNotIn        []string `json:"downgradedTierNotIn,omitempty"`
	DowngradedTierGt           *string  `json:"downgradedTierGT,omitempty"`
	DowngradedTierGte          *string  `json:"downgradedTierGTE,omitempty"`
	DowngradedTierLt           *string  `json:"downgradedTierLT,omitempty"`
	DowngradedTierLte          *string  `json:"downgradedTierLTE,omitempty"`
	DowngradedTierContains     *string  `json:"downgradedTierContains,omitempty"`
	DowngradedTierHasPrefix    *string  `json:"downgradedTierHasPrefix,omitempty"`
	DowngradedTierHasSuffix    *string  `json:"downgradedTierHasSuffix,omitempty"`
	DowngradedTierIsNil        *bool    `json:"downgradedTierIsNil,omitempty"`
	DowngradedTierNotNil       *bool    `json:"downgradedTierNotNil,omitempty"`
	DowngradedTierEqualFold    *string  `json:"downgradedTierEqualFold,omitempty"`
	DowngradedTierContainsFold *string  `json:"downgradedTierContainsFold,omitempty"`
	// cancelled field predicates
	Cancelled    *bool `json:"cancelled,omitempty"`
	CancelledNeq *bool `json:"cancelledNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Group struct {
	ID          string     `json:"id"`
	CreatedAt   time.Time  `json:"createdAt"`
	UpdatedAt   time.Time  `json:"updatedAt"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time `json:"deletedAt,omitempty"`
	DeletedBy   *string    `json:"deletedBy,omitempty"`
	Name        string     `json:"name"`
	Description string     `json:"description"`
	LogoURL     string     `json:"logoURL"`
	// The group's displayed 'friendly' name
	DisplayName string       `json:"displayName"`
	Setting     GroupSetting `json:"setting"`
	Users       []*User      `json:"users,omitempty"`
	Owner       Organization `json:"owner"`
}

func (Group) IsNode() {}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

type GroupSetting struct {
	ID         string                  `json:"id"`
	CreatedAt  time.Time               `json:"createdAt"`
	UpdatedAt  time.Time               `json:"updatedAt"`
	CreatedBy  *string                 `json:"createdBy,omitempty"`
	UpdatedBy  *string                 `json:"updatedBy,omitempty"`
	Visibility groupsetting.Visibility `json:"visibility"`
	JoinPolicy groupsetting.JoinPolicy `json:"joinPolicy"`
	// tags associated with the object
	Tags         []string `json:"tags"`
	SyncToSlack  bool     `json:"syncToSlack"`
	SyncToGithub bool     `json:"syncToGithub"`
	Group        *Group   `json:"group,omitempty"`
}

func (GroupSetting) IsNode() {}

// A connection to a list of items.
type GroupSettingConnection struct {
	// A list of edges.
	Edges []*GroupSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupSetting mutation
type GroupSettingCreatePayload struct {
	// Created groupSetting
	GroupSetting GroupSetting `json:"groupSetting"`
}

// Return response for deleteGroupSetting mutation
type GroupSettingDeletePayload struct {
	// Deleted groupSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupSettingEdge struct {
	// The item at the end of the edge.
	Node *GroupSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateGroupSetting mutation
type GroupSettingUpdatePayload struct {
	// Updated groupSetting
	GroupSetting GroupSetting `json:"groupSetting"`
}

// GroupSettingWhereInput is used for filtering GroupSetting objects.
// Input was generated by ent.
type GroupSettingWhereInput struct {
	Not *GroupSettingWhereInput   `json:"not,omitempty"`
	And []*GroupSettingWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *groupsetting.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *groupsetting.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []groupsetting.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []groupsetting.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *groupsetting.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *groupsetting.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []groupsetting.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []groupsetting.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack    *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq *bool `json:"syncToSlackNEQ,omitempty"`
	// sync_to_github field predicates
	SyncToGithub    *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq *bool `json:"syncToGithubNEQ,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Integration struct {
	ID          string        `json:"id"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
	CreatedBy   *string       `json:"createdBy,omitempty"`
	UpdatedBy   *string       `json:"updatedBy,omitempty"`
	Name        string        `json:"name"`
	Kind        string        `json:"kind"`
	Description *string       `json:"description,omitempty"`
	SecretName  string        `json:"secretName"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (Integration) IsNode() {}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type OauthProvider struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// the provider's name
	Name string `json:"name"`
	// the client id
	ClientID string `json:"clientID"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle int64 `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string        `json:"infoURL"`
	Owner   *Organization `json:"owner,omitempty"`
}

func (OauthProvider) IsNode() {}

// A connection to a list of items.
type OauthProviderConnection struct {
	// A list of edges.
	Edges []*OauthProviderEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOauthprovider mutation
type OauthProviderCreatePayload struct {
	// Created oauthProvider
	OauthProvider OauthProvider `json:"OauthProvider"`
}

// Return response for deleteOauthprovider mutation
type OauthProviderDeletePayload struct {
	// Deleted oauthProvider ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OauthProviderEdge struct {
	// The item at the end of the edge.
	Node *OauthProvider `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateOauthprovider mutation
type OauthProviderUpdatePayload struct {
	// Updated oauthProvider
	OauthProvider OauthProvider `json:"OauthProvider"`
}

// OauthProviderWhereInput is used for filtering OauthProvider objects.
// Input was generated by ent.
type OauthProviderWhereInput struct {
	Not *OauthProviderWhereInput   `json:"not,omitempty"`
	And []*OauthProviderWhereInput `json:"and,omitempty"`
	Or  []*OauthProviderWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// redirect_url field predicates
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNeq          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGt           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGte          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLt           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLte          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`
	// scopes field predicates
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNeq          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGt           *string  `json:"scopesGT,omitempty"`
	ScopesGte          *string  `json:"scopesGTE,omitempty"`
	ScopesLt           *string  `json:"scopesLT,omitempty"`
	ScopesLte          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`
	// auth_url field predicates
	AuthURL             *string  `json:"authURL,omitempty"`
	AuthURLNeq          *string  `json:"authURLNEQ,omitempty"`
	AuthURLIn           []string `json:"authURLIn,omitempty"`
	AuthURLNotIn        []string `json:"authURLNotIn,omitempty"`
	AuthURLGt           *string  `json:"authURLGT,omitempty"`
	AuthURLGte          *string  `json:"authURLGTE,omitempty"`
	AuthURLLt           *string  `json:"authURLLT,omitempty"`
	AuthURLLte          *string  `json:"authURLLTE,omitempty"`
	AuthURLContains     *string  `json:"authURLContains,omitempty"`
	AuthURLHasPrefix    *string  `json:"authURLHasPrefix,omitempty"`
	AuthURLHasSuffix    *string  `json:"authURLHasSuffix,omitempty"`
	AuthURLEqualFold    *string  `json:"authURLEqualFold,omitempty"`
	AuthURLContainsFold *string  `json:"authURLContainsFold,omitempty"`
	// token_url field predicates
	TokenURL             *string  `json:"tokenURL,omitempty"`
	TokenURLNeq          *string  `json:"tokenURLNEQ,omitempty"`
	TokenURLIn           []string `json:"tokenURLIn,omitempty"`
	TokenURLNotIn        []string `json:"tokenURLNotIn,omitempty"`
	TokenURLGt           *string  `json:"tokenURLGT,omitempty"`
	TokenURLGte          *string  `json:"tokenURLGTE,omitempty"`
	TokenURLLt           *string  `json:"tokenURLLT,omitempty"`
	TokenURLLte          *string  `json:"tokenURLLTE,omitempty"`
	TokenURLContains     *string  `json:"tokenURLContains,omitempty"`
	TokenURLHasPrefix    *string  `json:"tokenURLHasPrefix,omitempty"`
	TokenURLHasSuffix    *string  `json:"tokenURLHasSuffix,omitempty"`
	TokenURLEqualFold    *string  `json:"tokenURLEqualFold,omitempty"`
	TokenURLContainsFold *string  `json:"tokenURLContainsFold,omitempty"`
	// auth_style field predicates
	AuthStyle      *int64  `json:"authStyle,omitempty"`
	AuthStyleNeq   *int64  `json:"authStyleNEQ,omitempty"`
	AuthStyleIn    []int64 `json:"authStyleIn,omitempty"`
	AuthStyleNotIn []int64 `json:"authStyleNotIn,omitempty"`
	AuthStyleGt    *int64  `json:"authStyleGT,omitempty"`
	AuthStyleGte   *int64  `json:"authStyleGTE,omitempty"`
	AuthStyleLt    *int64  `json:"authStyleLT,omitempty"`
	AuthStyleLte   *int64  `json:"authStyleLTE,omitempty"`
	// info_url field predicates
	InfoURL             *string  `json:"infoURL,omitempty"`
	InfoURLNeq          *string  `json:"infoURLNEQ,omitempty"`
	InfoURLIn           []string `json:"infoURLIn,omitempty"`
	InfoURLNotIn        []string `json:"infoURLNotIn,omitempty"`
	InfoURLGt           *string  `json:"infoURLGT,omitempty"`
	InfoURLGte          *string  `json:"infoURLGTE,omitempty"`
	InfoURLLt           *string  `json:"infoURLLT,omitempty"`
	InfoURLLte          *string  `json:"infoURLLTE,omitempty"`
	InfoURLContains     *string  `json:"infoURLContains,omitempty"`
	InfoURLHasPrefix    *string  `json:"infoURLHasPrefix,omitempty"`
	InfoURLHasSuffix    *string  `json:"infoURLHasSuffix,omitempty"`
	InfoURLEqualFold    *string  `json:"infoURLEqualFold,omitempty"`
	InfoURLContainsFold *string  `json:"infoURLContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Organization struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt time.Time  `json:"updatedAt"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Name      string     `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description   *string                `json:"description,omitempty"`
	Parent        *Organization          `json:"parent,omitempty"`
	Children      OrganizationConnection `json:"children"`
	Users         []*User                `json:"users,omitempty"`
	Groups        []*Group               `json:"groups,omitempty"`
	Integrations  []*Integration         `json:"integrations,omitempty"`
	Setting       *OrganizationSetting   `json:"setting,omitempty"`
	Entitlements  []*Entitlement         `json:"entitlements,omitempty"`
	Oauthprovider []*OauthProvider       `json:"oauthprovider,omitempty"`
}

func (Organization) IsNode() {}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSetting struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains"`
	SsoCert       string   `json:"ssoCert"`
	SsoEntrypoint string   `json:"ssoEntrypoint"`
	SsoIssuer     string   `json:"ssoIssuer"`
	// Name of the person to contact for billing
	BillingContact string `json:"billingContact"`
	BillingEmail   string `json:"billingEmail"`
	BillingPhone   string `json:"billingPhone"`
	BillingAddress string `json:"billingAddress"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier string `json:"taxIdentifier"`
	// tags associated with the object
	Tags         []string      `json:"tags,omitempty"`
	Organization *Organization `json:"organization,omitempty"`
}

func (OrganizationSetting) IsNode() {}

// A connection to a list of items.
type OrganizationSettingConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganizationSetting mutation
type OrganizationSettingCreatePayload struct {
	// Created organizationSetting
	OrganizationSetting OrganizationSetting `json:"organizationSetting"`
}

// Return response for deleteOrganizationSetting mutation
type OrganizationSettingDeletePayload struct {
	// Deleted organizationSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationSettingEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateOrganizationSetting mutation
type OrganizationSettingUpdatePayload struct {
	// Updated organizationSetting
	OrganizationSetting OrganizationSetting `json:"organizationSetting"`
}

// OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
// Input was generated by ent.
type OrganizationSettingWhereInput struct {
	Not *OrganizationSettingWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// sso_cert field predicates
	SsoCert             *string  `json:"ssoCert,omitempty"`
	SsoCertNeq          *string  `json:"ssoCertNEQ,omitempty"`
	SsoCertIn           []string `json:"ssoCertIn,omitempty"`
	SsoCertNotIn        []string `json:"ssoCertNotIn,omitempty"`
	SsoCertGt           *string  `json:"ssoCertGT,omitempty"`
	SsoCertGte          *string  `json:"ssoCertGTE,omitempty"`
	SsoCertLt           *string  `json:"ssoCertLT,omitempty"`
	SsoCertLte          *string  `json:"ssoCertLTE,omitempty"`
	SsoCertContains     *string  `json:"ssoCertContains,omitempty"`
	SsoCertHasPrefix    *string  `json:"ssoCertHasPrefix,omitempty"`
	SsoCertHasSuffix    *string  `json:"ssoCertHasSuffix,omitempty"`
	SsoCertEqualFold    *string  `json:"ssoCertEqualFold,omitempty"`
	SsoCertContainsFold *string  `json:"ssoCertContainsFold,omitempty"`
	// sso_entrypoint field predicates
	SsoEntrypoint             *string  `json:"ssoEntrypoint,omitempty"`
	SsoEntrypointNeq          *string  `json:"ssoEntrypointNEQ,omitempty"`
	SsoEntrypointIn           []string `json:"ssoEntrypointIn,omitempty"`
	SsoEntrypointNotIn        []string `json:"ssoEntrypointNotIn,omitempty"`
	SsoEntrypointGt           *string  `json:"ssoEntrypointGT,omitempty"`
	SsoEntrypointGte          *string  `json:"ssoEntrypointGTE,omitempty"`
	SsoEntrypointLt           *string  `json:"ssoEntrypointLT,omitempty"`
	SsoEntrypointLte          *string  `json:"ssoEntrypointLTE,omitempty"`
	SsoEntrypointContains     *string  `json:"ssoEntrypointContains,omitempty"`
	SsoEntrypointHasPrefix    *string  `json:"ssoEntrypointHasPrefix,omitempty"`
	SsoEntrypointHasSuffix    *string  `json:"ssoEntrypointHasSuffix,omitempty"`
	SsoEntrypointEqualFold    *string  `json:"ssoEntrypointEqualFold,omitempty"`
	SsoEntrypointContainsFold *string  `json:"ssoEntrypointContainsFold,omitempty"`
	// sso_issuer field predicates
	SsoIssuer             *string  `json:"ssoIssuer,omitempty"`
	SsoIssuerNeq          *string  `json:"ssoIssuerNEQ,omitempty"`
	SsoIssuerIn           []string `json:"ssoIssuerIn,omitempty"`
	SsoIssuerNotIn        []string `json:"ssoIssuerNotIn,omitempty"`
	SsoIssuerGt           *string  `json:"ssoIssuerGT,omitempty"`
	SsoIssuerGte          *string  `json:"ssoIssuerGTE,omitempty"`
	SsoIssuerLt           *string  `json:"ssoIssuerLT,omitempty"`
	SsoIssuerLte          *string  `json:"ssoIssuerLTE,omitempty"`
	SsoIssuerContains     *string  `json:"ssoIssuerContains,omitempty"`
	SsoIssuerHasPrefix    *string  `json:"ssoIssuerHasPrefix,omitempty"`
	SsoIssuerHasSuffix    *string  `json:"ssoIssuerHasSuffix,omitempty"`
	SsoIssuerEqualFold    *string  `json:"ssoIssuerEqualFold,omitempty"`
	SsoIssuerContainsFold *string  `json:"ssoIssuerContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// billing_address field predicates
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNeq          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGt           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGte          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLt           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLte          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNeq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`
	// entitlements edge predicates
	HasEntitlements     *bool                    `json:"hasEntitlements,omitempty"`
	HasEntitlementsWith []*EntitlementWhereInput `json:"hasEntitlementsWith,omitempty"`
	// oauthprovider edge predicates
	HasOauthprovider     *bool                      `json:"hasOauthprovider,omitempty"`
	HasOauthproviderWith []*OauthProviderWhereInput `json:"hasOauthproviderWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID           string     `json:"id"`
	CreatedAt    time.Time  `json:"createdAt"`
	UpdatedAt    time.Time  `json:"updatedAt"`
	CreatedBy    *string    `json:"createdBy,omitempty"`
	UpdatedBy    *string    `json:"updatedBy,omitempty"`
	Name         string     `json:"name"`
	Abilities    []string   `json:"abilities,omitempty"`
	ExpirationAt time.Time  `json:"expirationAt"`
	Description  string     `json:"description"`
	LastUsedAt   *time.Time `json:"lastUsedAt,omitempty"`
	Owner        User       `json:"owner"`
}

func (PersonalAccessToken) IsNode() {}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created personalAccessToken
	PersonalAccessToken PersonalAccessToken `json:"PersonalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted personalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated personalAccessToken
	PersonalAccessToken PersonalAccessToken `json:"PersonalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expiration_at field predicates
	ExpirationAt      *time.Time   `json:"expirationAt,omitempty"`
	ExpirationAtNeq   *time.Time   `json:"expirationAtNEQ,omitempty"`
	ExpirationAtIn    []*time.Time `json:"expirationAtIn,omitempty"`
	ExpirationAtNotIn []*time.Time `json:"expirationAtNotIn,omitempty"`
	ExpirationAtGt    *time.Time   `json:"expirationAtGT,omitempty"`
	ExpirationAtGte   *time.Time   `json:"expirationAtGTE,omitempty"`
	ExpirationAtLt    *time.Time   `json:"expirationAtLT,omitempty"`
	ExpirationAtLte   *time.Time   `json:"expirationAtLTE,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type RefreshToken struct {
	ID                      string    `json:"id"`
	ClientID                string    `json:"clientID"`
	Scopes                  []string  `json:"scopes,omitempty"`
	Nonce                   string    `json:"nonce"`
	ClaimsUserID            string    `json:"claimsUserID"`
	ClaimsUsername          string    `json:"claimsUsername"`
	ClaimsEmail             string    `json:"claimsEmail"`
	ClaimsEmailVerified     bool      `json:"claimsEmailVerified"`
	ClaimsGroups            []string  `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string    `json:"claimsPreferredUsername"`
	ConnectorID             string    `json:"connectorID"`
	ConnectorData           []string  `json:"connectorData,omitempty"`
	Token                   string    `json:"token"`
	ObsoleteToken           string    `json:"obsoleteToken"`
	LastUsed                time.Time `json:"lastUsed"`
	User                    *User     `json:"user,omitempty"`
}

func (RefreshToken) IsNode() {}

// A connection to a list of items.
type RefreshTokenConnection struct {
	// A list of edges.
	Edges []*RefreshTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRefreshToken mutation
type RefreshTokenCreatePayload struct {
	// Created refreshToken
	RefreshToken RefreshToken `json:"refreshToken"`
}

// Return response for deleteRefreshToken mutation
type RefreshTokenDeletePayload struct {
	// Deleted refreshToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type RefreshTokenEdge struct {
	// The item at the end of the edge.
	Node *RefreshToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateRefreshToken mutation
type RefreshTokenUpdatePayload struct {
	// Updated refreshToken
	RefreshToken RefreshToken `json:"refreshToken"`
}

// RefreshTokenWhereInput is used for filtering RefreshToken objects.
// Input was generated by ent.
type RefreshTokenWhereInput struct {
	Not *RefreshTokenWhereInput   `json:"not,omitempty"`
	And []*RefreshTokenWhereInput `json:"and,omitempty"`
	Or  []*RefreshTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// nonce field predicates
	Nonce             *string  `json:"nonce,omitempty"`
	NonceNeq          *string  `json:"nonceNEQ,omitempty"`
	NonceIn           []string `json:"nonceIn,omitempty"`
	NonceNotIn        []string `json:"nonceNotIn,omitempty"`
	NonceGt           *string  `json:"nonceGT,omitempty"`
	NonceGte          *string  `json:"nonceGTE,omitempty"`
	NonceLt           *string  `json:"nonceLT,omitempty"`
	NonceLte          *string  `json:"nonceLTE,omitempty"`
	NonceContains     *string  `json:"nonceContains,omitempty"`
	NonceHasPrefix    *string  `json:"nonceHasPrefix,omitempty"`
	NonceHasSuffix    *string  `json:"nonceHasSuffix,omitempty"`
	NonceEqualFold    *string  `json:"nonceEqualFold,omitempty"`
	NonceContainsFold *string  `json:"nonceContainsFold,omitempty"`
	// claims_user_id field predicates
	ClaimsUserID             *string  `json:"claimsUserID,omitempty"`
	ClaimsUserIDNeq          *string  `json:"claimsUserIDNEQ,omitempty"`
	ClaimsUserIDIn           []string `json:"claimsUserIDIn,omitempty"`
	ClaimsUserIDNotIn        []string `json:"claimsUserIDNotIn,omitempty"`
	ClaimsUserIDGt           *string  `json:"claimsUserIDGT,omitempty"`
	ClaimsUserIDGte          *string  `json:"claimsUserIDGTE,omitempty"`
	ClaimsUserIDLt           *string  `json:"claimsUserIDLT,omitempty"`
	ClaimsUserIDLte          *string  `json:"claimsUserIDLTE,omitempty"`
	ClaimsUserIDContains     *string  `json:"claimsUserIDContains,omitempty"`
	ClaimsUserIDHasPrefix    *string  `json:"claimsUserIDHasPrefix,omitempty"`
	ClaimsUserIDHasSuffix    *string  `json:"claimsUserIDHasSuffix,omitempty"`
	ClaimsUserIDEqualFold    *string  `json:"claimsUserIDEqualFold,omitempty"`
	ClaimsUserIDContainsFold *string  `json:"claimsUserIDContainsFold,omitempty"`
	// claims_username field predicates
	ClaimsUsername             *string  `json:"claimsUsername,omitempty"`
	ClaimsUsernameNeq          *string  `json:"claimsUsernameNEQ,omitempty"`
	ClaimsUsernameIn           []string `json:"claimsUsernameIn,omitempty"`
	ClaimsUsernameNotIn        []string `json:"claimsUsernameNotIn,omitempty"`
	ClaimsUsernameGt           *string  `json:"claimsUsernameGT,omitempty"`
	ClaimsUsernameGte          *string  `json:"claimsUsernameGTE,omitempty"`
	ClaimsUsernameLt           *string  `json:"claimsUsernameLT,omitempty"`
	ClaimsUsernameLte          *string  `json:"claimsUsernameLTE,omitempty"`
	ClaimsUsernameContains     *string  `json:"claimsUsernameContains,omitempty"`
	ClaimsUsernameHasPrefix    *string  `json:"claimsUsernameHasPrefix,omitempty"`
	ClaimsUsernameHasSuffix    *string  `json:"claimsUsernameHasSuffix,omitempty"`
	ClaimsUsernameEqualFold    *string  `json:"claimsUsernameEqualFold,omitempty"`
	ClaimsUsernameContainsFold *string  `json:"claimsUsernameContainsFold,omitempty"`
	// claims_email field predicates
	ClaimsEmail             *string  `json:"claimsEmail,omitempty"`
	ClaimsEmailNeq          *string  `json:"claimsEmailNEQ,omitempty"`
	ClaimsEmailIn           []string `json:"claimsEmailIn,omitempty"`
	ClaimsEmailNotIn        []string `json:"claimsEmailNotIn,omitempty"`
	ClaimsEmailGt           *string  `json:"claimsEmailGT,omitempty"`
	ClaimsEmailGte          *string  `json:"claimsEmailGTE,omitempty"`
	ClaimsEmailLt           *string  `json:"claimsEmailLT,omitempty"`
	ClaimsEmailLte          *string  `json:"claimsEmailLTE,omitempty"`
	ClaimsEmailContains     *string  `json:"claimsEmailContains,omitempty"`
	ClaimsEmailHasPrefix    *string  `json:"claimsEmailHasPrefix,omitempty"`
	ClaimsEmailHasSuffix    *string  `json:"claimsEmailHasSuffix,omitempty"`
	ClaimsEmailEqualFold    *string  `json:"claimsEmailEqualFold,omitempty"`
	ClaimsEmailContainsFold *string  `json:"claimsEmailContainsFold,omitempty"`
	// claims_email_verified field predicates
	ClaimsEmailVerified    *bool `json:"claimsEmailVerified,omitempty"`
	ClaimsEmailVerifiedNeq *bool `json:"claimsEmailVerifiedNEQ,omitempty"`
	// claims_preferred_username field predicates
	ClaimsPreferredUsername             *string  `json:"claimsPreferredUsername,omitempty"`
	ClaimsPreferredUsernameNeq          *string  `json:"claimsPreferredUsernameNEQ,omitempty"`
	ClaimsPreferredUsernameIn           []string `json:"claimsPreferredUsernameIn,omitempty"`
	ClaimsPreferredUsernameNotIn        []string `json:"claimsPreferredUsernameNotIn,omitempty"`
	ClaimsPreferredUsernameGt           *string  `json:"claimsPreferredUsernameGT,omitempty"`
	ClaimsPreferredUsernameGte          *string  `json:"claimsPreferredUsernameGTE,omitempty"`
	ClaimsPreferredUsernameLt           *string  `json:"claimsPreferredUsernameLT,omitempty"`
	ClaimsPreferredUsernameLte          *string  `json:"claimsPreferredUsernameLTE,omitempty"`
	ClaimsPreferredUsernameContains     *string  `json:"claimsPreferredUsernameContains,omitempty"`
	ClaimsPreferredUsernameHasPrefix    *string  `json:"claimsPreferredUsernameHasPrefix,omitempty"`
	ClaimsPreferredUsernameHasSuffix    *string  `json:"claimsPreferredUsernameHasSuffix,omitempty"`
	ClaimsPreferredUsernameEqualFold    *string  `json:"claimsPreferredUsernameEqualFold,omitempty"`
	ClaimsPreferredUsernameContainsFold *string  `json:"claimsPreferredUsernameContainsFold,omitempty"`
	// connector_id field predicates
	ConnectorID             *string  `json:"connectorID,omitempty"`
	ConnectorIDNeq          *string  `json:"connectorIDNEQ,omitempty"`
	ConnectorIDIn           []string `json:"connectorIDIn,omitempty"`
	ConnectorIDNotIn        []string `json:"connectorIDNotIn,omitempty"`
	ConnectorIDGt           *string  `json:"connectorIDGT,omitempty"`
	ConnectorIDGte          *string  `json:"connectorIDGTE,omitempty"`
	ConnectorIDLt           *string  `json:"connectorIDLT,omitempty"`
	ConnectorIDLte          *string  `json:"connectorIDLTE,omitempty"`
	ConnectorIDContains     *string  `json:"connectorIDContains,omitempty"`
	ConnectorIDHasPrefix    *string  `json:"connectorIDHasPrefix,omitempty"`
	ConnectorIDHasSuffix    *string  `json:"connectorIDHasSuffix,omitempty"`
	ConnectorIDEqualFold    *string  `json:"connectorIDEqualFold,omitempty"`
	ConnectorIDContainsFold *string  `json:"connectorIDContainsFold,omitempty"`
	// token field predicates
	Token             *string  `json:"token,omitempty"`
	TokenNeq          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGt           *string  `json:"tokenGT,omitempty"`
	TokenGte          *string  `json:"tokenGTE,omitempty"`
	TokenLt           *string  `json:"tokenLT,omitempty"`
	TokenLte          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`
	// obsolete_token field predicates
	ObsoleteToken             *string  `json:"obsoleteToken,omitempty"`
	ObsoleteTokenNeq          *string  `json:"obsoleteTokenNEQ,omitempty"`
	ObsoleteTokenIn           []string `json:"obsoleteTokenIn,omitempty"`
	ObsoleteTokenNotIn        []string `json:"obsoleteTokenNotIn,omitempty"`
	ObsoleteTokenGt           *string  `json:"obsoleteTokenGT,omitempty"`
	ObsoleteTokenGte          *string  `json:"obsoleteTokenGTE,omitempty"`
	ObsoleteTokenLt           *string  `json:"obsoleteTokenLT,omitempty"`
	ObsoleteTokenLte          *string  `json:"obsoleteTokenLTE,omitempty"`
	ObsoleteTokenContains     *string  `json:"obsoleteTokenContains,omitempty"`
	ObsoleteTokenHasPrefix    *string  `json:"obsoleteTokenHasPrefix,omitempty"`
	ObsoleteTokenHasSuffix    *string  `json:"obsoleteTokenHasSuffix,omitempty"`
	ObsoleteTokenEqualFold    *string  `json:"obsoleteTokenEqualFold,omitempty"`
	ObsoleteTokenContainsFold *string  `json:"obsoleteTokenContainsFold,omitempty"`
	// last_used field predicates
	LastUsed      *time.Time   `json:"lastUsed,omitempty"`
	LastUsedNeq   *time.Time   `json:"lastUsedNEQ,omitempty"`
	LastUsedIn    []*time.Time `json:"lastUsedIn,omitempty"`
	LastUsedNotIn []*time.Time `json:"lastUsedNotIn,omitempty"`
	LastUsedGt    *time.Time   `json:"lastUsedGT,omitempty"`
	LastUsedGte   *time.Time   `json:"lastUsedGTE,omitempty"`
	LastUsedLt    *time.Time   `json:"lastUsedLT,omitempty"`
	LastUsedLte   *time.Time   `json:"lastUsedLTE,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

type Session struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token string `json:"token"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips string `json:"ips"`
	// Sessions belong to users
	Users *User `json:"users,omitempty"`
}

func (Session) IsNode() {}

// A connection to a list of items.
type SessionConnection struct {
	// A list of edges.
	Edges []*SessionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSession mutation
type SessionCreatePayload struct {
	// Created session
	Session Session `json:"session"`
}

// Return response for deleteSession mutation
type SessionDeletePayload struct {
	// Deleted session ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SessionEdge struct {
	// The item at the end of the edge.
	Node *Session `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateSession mutation
type SessionUpdatePayload struct {
	// Updated session
	Session Session `json:"session"`
}

// SessionWhereInput is used for filtering Session objects.
// Input was generated by ent.
type SessionWhereInput struct {
	Not *SessionWhereInput   `json:"not,omitempty"`
	And []*SessionWhereInput `json:"and,omitempty"`
	Or  []*SessionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// type field predicates
	Type      *session.Type  `json:"type,omitempty"`
	TypeNeq   *session.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []session.Type `json:"typeIn,omitempty"`
	TypeNotIn []session.Type `json:"typeNotIn,omitempty"`
	// disabled field predicates
	Disabled    *bool `json:"disabled,omitempty"`
	DisabledNeq *bool `json:"disabledNEQ,omitempty"`
	// token field predicates
	Token             *string  `json:"token,omitempty"`
	TokenNeq          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGt           *string  `json:"tokenGT,omitempty"`
	TokenGte          *string  `json:"tokenGTE,omitempty"`
	TokenLt           *string  `json:"tokenLT,omitempty"`
	TokenLte          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`
	// user_agent field predicates
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNeq          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGt           *string  `json:"userAgentGT,omitempty"`
	UserAgentGte          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLt           *string  `json:"userAgentLT,omitempty"`
	UserAgentLte          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentIsNil        *bool    `json:"userAgentIsNil,omitempty"`
	UserAgentNotNil       *bool    `json:"userAgentNotNil,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`
	// ips field predicates
	Ips             *string  `json:"ips,omitempty"`
	IpsNeq          *string  `json:"ipsNEQ,omitempty"`
	IpsIn           []string `json:"ipsIn,omitempty"`
	IpsNotIn        []string `json:"ipsNotIn,omitempty"`
	IpsGt           *string  `json:"ipsGT,omitempty"`
	IpsGte          *string  `json:"ipsGTE,omitempty"`
	IpsLt           *string  `json:"ipsLT,omitempty"`
	IpsLte          *string  `json:"ipsLTE,omitempty"`
	IpsContains     *string  `json:"ipsContains,omitempty"`
	IpsHasPrefix    *string  `json:"ipsHasPrefix,omitempty"`
	IpsHasSuffix    *string  `json:"ipsHasSuffix,omitempty"`
	IpsEqualFold    *string  `json:"ipsEqualFold,omitempty"`
	IpsContainsFold *string  `json:"ipsContainsFold,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// UpdateEntitlementInput is used for update Entitlement object.
// Input was generated by ent.
type UpdateEntitlementInput struct {
	UpdatedAt      *time.Time        `json:"updatedAt,omitempty"`
	UpdatedBy      *string           `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool             `json:"clearUpdatedBy,omitempty"`
	Tier           *entitlement.Tier `json:"tier,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID      *string `json:"externalCustomerID,omitempty"`
	ClearExternalCustomerID *bool   `json:"clearExternalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID      *string    `json:"externalSubscriptionID,omitempty"`
	ClearExternalSubscriptionID *bool      `json:"clearExternalSubscriptionID,omitempty"`
	ExpiresAt                   *time.Time `json:"expiresAt,omitempty"`
	ClearExpiresAt              *bool      `json:"clearExpiresAt,omitempty"`
	UpgradedAt                  *time.Time `json:"upgradedAt,omitempty"`
	ClearUpgradedAt             *bool      `json:"clearUpgradedAt,omitempty"`
	// the tier the customer upgraded from
	UpgradedTier      *string    `json:"upgradedTier,omitempty"`
	ClearUpgradedTier *bool      `json:"clearUpgradedTier,omitempty"`
	DowngradedAt      *time.Time `json:"downgradedAt,omitempty"`
	ClearDowngradedAt *bool      `json:"clearDowngradedAt,omitempty"`
	// the tier the customer downgraded from
	DowngradedTier      *string `json:"downgradedTier,omitempty"`
	ClearDowngradedTier *bool   `json:"clearDowngradedTier,omitempty"`
	Cancelled           *bool   `json:"cancelled,omitempty"`
	OwnerID             *string `json:"ownerID,omitempty"`
	ClearOwner          *bool   `json:"clearOwner,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	Description    *string    `json:"description,omitempty"`
	LogoURL        *string    `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName   *string  `json:"displayName,omitempty"`
	SettingID     *string  `json:"settingID,omitempty"`
	AddUserIDs    []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs []string `json:"removeUserIDs,omitempty"`
	ClearUsers    *bool    `json:"clearUsers,omitempty"`
	OwnerID       *string  `json:"ownerID,omitempty"`
}

// UpdateGroupSettingInput is used for update GroupSetting object.
// Input was generated by ent.
type UpdateGroupSettingInput struct {
	UpdatedAt      *time.Time               `json:"updatedAt,omitempty"`
	UpdatedBy      *string                  `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool                    `json:"clearUpdatedBy,omitempty"`
	Visibility     *groupsetting.Visibility `json:"visibility,omitempty"`
	JoinPolicy     *groupsetting.JoinPolicy `json:"joinPolicy,omitempty"`
	// tags associated with the object
	Tags         []string `json:"tags,omitempty"`
	AppendTags   []string `json:"appendTags,omitempty"`
	SyncToSlack  *bool    `json:"syncToSlack,omitempty"`
	SyncToGithub *bool    `json:"syncToGithub,omitempty"`
	GroupID      *string  `json:"groupID,omitempty"`
	ClearGroup   *bool    `json:"clearGroup,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy        *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy   *bool      `json:"clearUpdatedBy,omitempty"`
	Name             *string    `json:"name,omitempty"`
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	OwnerID          *string    `json:"ownerID,omitempty"`
	ClearOwner       *bool      `json:"clearOwner,omitempty"`
}

// UpdateOauthProviderInput is used for update OauthProvider object.
// Input was generated by ent.
type UpdateOauthProviderInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// the provider's name
	Name *string `json:"name,omitempty"`
	// the client id
	ClientID *string `json:"clientID,omitempty"`
	// the client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// the redirect url
	RedirectURL *string `json:"redirectURL,omitempty"`
	// the scopes
	Scopes *string `json:"scopes,omitempty"`
	// the auth url of the provider
	AuthURL *string `json:"authURL,omitempty"`
	// the token url of the provider
	TokenURL *string `json:"tokenURL,omitempty"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle *int64 `json:"authStyle,omitempty"`
	// the URL to request user information by token
	InfoURL    *string `json:"infoURL,omitempty"`
	OwnerID    *string `json:"ownerID,omitempty"`
	ClearOwner *bool   `json:"clearOwner,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description            *string  `json:"description,omitempty"`
	ClearDescription       *bool    `json:"clearDescription,omitempty"`
	AddUserIDs             []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs          []string `json:"removeUserIDs,omitempty"`
	ClearUsers             *bool    `json:"clearUsers,omitempty"`
	AddGroupIDs            []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs         []string `json:"removeGroupIDs,omitempty"`
	ClearGroups            *bool    `json:"clearGroups,omitempty"`
	AddIntegrationIDs      []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs   []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations      *bool    `json:"clearIntegrations,omitempty"`
	SettingID              *string  `json:"settingID,omitempty"`
	ClearSetting           *bool    `json:"clearSetting,omitempty"`
	AddEntitlementIDs      []string `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs   []string `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlements      *bool    `json:"clearEntitlements,omitempty"`
	AddOauthproviderIDs    []string `json:"addOauthproviderIDs,omitempty"`
	RemoveOauthproviderIDs []string `json:"removeOauthproviderIDs,omitempty"`
	ClearOauthprovider     *bool    `json:"clearOauthprovider,omitempty"`
}

// UpdateOrganizationSettingInput is used for update OrganizationSetting object.
// Input was generated by ent.
type UpdateOrganizationSettingInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	SsoCert       *string  `json:"ssoCert,omitempty"`
	SsoEntrypoint *string  `json:"ssoEntrypoint,omitempty"`
	SsoIssuer     *string  `json:"ssoIssuer,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	BillingEmail   *string `json:"billingEmail,omitempty"`
	BillingPhone   *string `json:"billingPhone,omitempty"`
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// tags associated with the object
	Tags              []string `json:"tags,omitempty"`
	AppendTags        []string `json:"appendTags,omitempty"`
	ClearTags         *bool    `json:"clearTags,omitempty"`
	OrganizationID    *string  `json:"organizationID,omitempty"`
	ClearOrganization *bool    `json:"clearOrganization,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	UpdatedAt       *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy       *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy  *bool      `json:"clearUpdatedBy,omitempty"`
	Name            *string    `json:"name,omitempty"`
	Abilities       []string   `json:"abilities,omitempty"`
	AppendAbilities []string   `json:"appendAbilities,omitempty"`
	ClearAbilities  *bool      `json:"clearAbilities,omitempty"`
	ExpirationAt    *time.Time `json:"expirationAt,omitempty"`
	Description     *string    `json:"description,omitempty"`
	LastUsedAt      *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt *bool      `json:"clearLastUsedAt,omitempty"`
	OwnerID         *string    `json:"ownerID,omitempty"`
}

// UpdateRefreshTokenInput is used for update RefreshToken object.
// Input was generated by ent.
type UpdateRefreshTokenInput struct {
	ClientID                *string    `json:"clientID,omitempty"`
	Scopes                  []string   `json:"scopes,omitempty"`
	AppendScopes            []string   `json:"appendScopes,omitempty"`
	ClearScopes             *bool      `json:"clearScopes,omitempty"`
	Nonce                   *string    `json:"nonce,omitempty"`
	ClaimsUserID            *string    `json:"claimsUserID,omitempty"`
	ClaimsUsername          *string    `json:"claimsUsername,omitempty"`
	ClaimsEmail             *string    `json:"claimsEmail,omitempty"`
	ClaimsEmailVerified     *bool      `json:"claimsEmailVerified,omitempty"`
	ClaimsGroups            []string   `json:"claimsGroups,omitempty"`
	AppendClaimsGroups      []string   `json:"appendClaimsGroups,omitempty"`
	ClearClaimsGroups       *bool      `json:"clearClaimsGroups,omitempty"`
	ClaimsPreferredUsername *string    `json:"claimsPreferredUsername,omitempty"`
	ConnectorID             *string    `json:"connectorID,omitempty"`
	ConnectorData           []string   `json:"connectorData,omitempty"`
	AppendConnectorData     []string   `json:"appendConnectorData,omitempty"`
	ClearConnectorData      *bool      `json:"clearConnectorData,omitempty"`
	Token                   *string    `json:"token,omitempty"`
	ObsoleteToken           *string    `json:"obsoleteToken,omitempty"`
	LastUsed                *time.Time `json:"lastUsed,omitempty"`
	UserID                  *string    `json:"userID,omitempty"`
	ClearUser               *bool      `json:"clearUser,omitempty"`
}

// UpdateSessionInput is used for update Session object.
// Input was generated by ent.
type UpdateSessionInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// The session may be disabled by the user or by automatic security policy
	Disabled *bool `json:"disabled,omitempty"`
	// The last known user-agent
	UserAgent      *string `json:"userAgent,omitempty"`
	ClearUserAgent *bool   `json:"clearUserAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips        *string `json:"ips,omitempty"`
	UsersID    *string `json:"usersID,omitempty"`
	ClearUsers *bool   `json:"clearUsers,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Email          *string    `json:"email,omitempty"`
	FirstName      *string    `json:"firstName,omitempty"`
	LastName       *string    `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile      *string `json:"avatarLocalFile,omitempty"`
	ClearAvatarLocalFile *bool   `json:"clearAvatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// user bcrypt password hash
	Password      *string `json:"password,omitempty"`
	ClearPassword *bool   `json:"clearPassword,omitempty"`
	// the Subject of the user JWT
	Sub      *string `json:"sub,omitempty"`
	ClearSub *bool   `json:"clearSub,omitempty"`
	// whether the user uses oauth for login or not
	Oauth                        *bool    `json:"oauth,omitempty"`
	AddOrganizationIDs           []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations           *bool    `json:"clearOrganizations,omitempty"`
	AddSessionIDs                []string `json:"addSessionIDs,omitempty"`
	RemoveSessionIDs             []string `json:"removeSessionIDs,omitempty"`
	ClearSessions                *bool    `json:"clearSessions,omitempty"`
	AddGroupIDs                  []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string `json:"removeGroupIDs,omitempty"`
	ClearGroups                  *bool    `json:"clearGroups,omitempty"`
	AddPersonalAccessTokenIDs    []string `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens    *bool    `json:"clearPersonalAccessTokens,omitempty"`
	SettingID                    *string  `json:"settingID,omitempty"`
	AddRefreshtokenIDs           []string `json:"addRefreshtokenIDs,omitempty"`
	RemoveRefreshtokenIDs        []string `json:"removeRefreshtokenIDs,omitempty"`
	ClearRefreshtoken            *bool    `json:"clearRefreshtoken,omitempty"`
}

// UpdateUserSettingInput is used for update UserSetting object.
// Input was generated by ent.
type UpdateUserSettingInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// local user password recovery code generated during account creation - does not exist for oauth'd users
	RecoveryCode      *string             `json:"recoveryCode,omitempty"`
	ClearRecoveryCode *bool               `json:"clearRecoveryCode,omitempty"`
	Status            *usersetting.Status `json:"status,omitempty"`
	Role              *usersetting.Role   `json:"role,omitempty"`
	Permissions       []string            `json:"permissions,omitempty"`
	AppendPermissions []string            `json:"appendPermissions,omitempty"`
	EmailConfirmed    *bool               `json:"emailConfirmed,omitempty"`
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	UserID     *string  `json:"userID,omitempty"`
	ClearUser  *bool    `json:"clearUser,omitempty"`
}

type User struct {
	ID        string     `json:"id"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt time.Time  `json:"updatedAt"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Email     string     `json:"email"`
	FirstName string     `json:"firstName"`
	LastName  string     `json:"lastName"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user bcrypt password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// whether the user uses oauth for login or not
	Oauth                bool                   `json:"oauth"`
	Organizations        []*Organization        `json:"organizations,omitempty"`
	Sessions             []*Session             `json:"sessions,omitempty"`
	Groups               []*Group               `json:"groups,omitempty"`
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
	Setting              UserSetting            `json:"setting"`
	Refreshtoken         []*RefreshToken        `json:"refreshtoken,omitempty"`
}

func (User) IsNode() {}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSetting struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt    *time.Time         `json:"suspendedAt,omitempty"`
	Status         usersetting.Status `json:"status"`
	Role           usersetting.Role   `json:"role"`
	Permissions    []string           `json:"permissions"`
	EmailConfirmed bool               `json:"emailConfirmed"`
	// tags associated with the object
	Tags []string `json:"tags"`
	User *User    `json:"user,omitempty"`
}

func (UserSetting) IsNode() {}

// A connection to a list of items.
type UserSettingConnection struct {
	// A list of edges.
	Edges []*UserSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSetting mutation
type UserSettingCreatePayload struct {
	// Created userSetting
	UserSetting UserSetting `json:"UserSetting"`
}

// Return response for deleteUserSetting mutation
type UserSettingDeletePayload struct {
	// Deleted userSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserSettingEdge struct {
	// The item at the end of the edge.
	Node *UserSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateUserSetting mutation
type UserSettingUpdatePayload struct {
	// Updated userSetting
	UserSetting UserSetting `json:"UserSetting"`
}

// UserSettingWhereInput is used for filtering UserSetting objects.
// Input was generated by ent.
type UserSettingWhereInput struct {
	Not *UserSettingWhereInput   `json:"not,omitempty"`
	And []*UserSettingWhereInput `json:"and,omitempty"`
	Or  []*UserSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *usersetting.Status  `json:"status,omitempty"`
	StatusNeq   *usersetting.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []usersetting.Status `json:"statusIn,omitempty"`
	StatusNotIn []usersetting.Status `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *usersetting.Role  `json:"role,omitempty"`
	RoleNeq   *usersetting.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []usersetting.Role `json:"roleIn,omitempty"`
	RoleNotIn []usersetting.Role `json:"roleNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// password field predicates
	Password             *string  `json:"password,omitempty"`
	PasswordNeq          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGt           *string  `json:"passwordGT,omitempty"`
	PasswordGte          *string  `json:"passwordGTE,omitempty"`
	PasswordLt           *string  `json:"passwordLT,omitempty"`
	PasswordLte          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        *bool    `json:"passwordIsNil,omitempty"`
	PasswordNotNil       *bool    `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// oauth field predicates
	Oauth    *bool `json:"oauth,omitempty"`
	OauthNeq *bool `json:"oauthNEQ,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// sessions edge predicates
	HasSessions     *bool                `json:"hasSessions,omitempty"`
	HasSessionsWith []*SessionWhereInput `json:"hasSessionsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`
	// refreshtoken edge predicates
	HasRefreshtoken     *bool                     `json:"hasRefreshtoken,omitempty"`
	HasRefreshtokenWith []*RefreshTokenWhereInput `json:"hasRefreshtokenWith,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldName IntegrationOrderField = "name"
	IntegrationOrderFieldKind IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
