// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package datumclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/datumforge/datum/internal/ent/generated/entitlement"
	"github.com/datumforge/datum/internal/ent/generated/groupsettings"
	"github.com/datumforge/datum/internal/ent/generated/session"
	"github.com/datumforge/datum/internal/ent/generated/usersettings"
)

// CreateEntitlementInput is used for create Entitlement object.
// Input was generated by ent.
type CreateEntitlementInput struct {
	CreatedAt            *time.Time        `json:"createdAt,omitempty"`
	UpdatedAt            *time.Time        `json:"updatedAt,omitempty"`
	CreatedBy            *string           `json:"createdBy,omitempty"`
	UpdatedBy            *string           `json:"updatedBy,omitempty"`
	Tier                 *entitlement.Tier `json:"tier,omitempty"`
	StripeCustomerID     *string           `json:"stripeCustomerID,omitempty"`
	StripeSubscriptionID *string           `json:"stripeSubscriptionID,omitempty"`
	ExpiresAt            *time.Time        `json:"expiresAt,omitempty"`
	Cancelled            *bool             `json:"cancelled,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	Name        string     `json:"name"`
	Description *string    `json:"description,omitempty"`
	LogoURL     string     `json:"logoURL"`
	// The group's displayed 'friendly' name
	DisplayName *string  `json:"displayName,omitempty"`
	SettingID   string   `json:"settingID"`
	UserIDs     []string `json:"userIDs,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
}

// CreateGroupSettingsInput is used for create GroupSettings object.
// Input was generated by ent.
type CreateGroupSettingsInput struct {
	CreatedAt  *time.Time                `json:"createdAt,omitempty"`
	UpdatedAt  *time.Time                `json:"updatedAt,omitempty"`
	CreatedBy  *string                   `json:"createdBy,omitempty"`
	UpdatedBy  *string                   `json:"updatedBy,omitempty"`
	Visibility *groupsettings.Visibility `json:"visibility,omitempty"`
	JoinPolicy *groupsettings.JoinPolicy `json:"joinPolicy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	Name        string     `json:"name"`
	Kind        string     `json:"kind"`
	Description *string    `json:"description,omitempty"`
	SecretName  string     `json:"secretName"`
	OwnerID     *string    `json:"ownerID,omitempty"`
}

// CreateOauthProviderInput is used for create OauthProvider object.
// Input was generated by ent.
type CreateOauthProviderInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the provider's name
	Name string `json:"name"`
	// the client id
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle int64 `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string `json:"infoURL"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Name      string     `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the Organization
	Description    *string  `json:"description,omitempty"`
	ParentID       *string  `json:"parentID,omitempty"`
	UserIDs        []string `json:"userIDs,omitempty"`
	GroupIDs       []string `json:"groupIDs,omitempty"`
	IntegrationIDs []string `json:"integrationIDs,omitempty"`
	SettingID      string   `json:"settingID"`
}

// CreateOrganizationSettingsInput is used for create OrganizationSettings object.
// Input was generated by ent.
type CreateOrganizationSettingsInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains"`
	SsoCert       *string  `json:"ssoCert,omitempty"`
	SsoEntrypoint *string  `json:"ssoEntrypoint,omitempty"`
	SsoIssuer     *string  `json:"ssoIssuer,omitempty"`
	// Name of the person to contact for billing
	BillingContact string `json:"billingContact"`
	BillingEmail   string `json:"billingEmail"`
	BillingPhone   string `json:"billingPhone"`
	BillingAddress string `json:"billingAddress"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier string `json:"taxIdentifier"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
	UpdatedAt    *time.Time `json:"updatedAt,omitempty"`
	CreatedBy    *string    `json:"createdBy,omitempty"`
	UpdatedBy    *string    `json:"updatedBy,omitempty"`
	Name         string     `json:"name"`
	Token        string     `json:"token"`
	Abilities    []string   `json:"abilities,omitempty"`
	ExpirationAt time.Time  `json:"expirationAt"`
	LastUsedAt   *time.Time `json:"lastUsedAt,omitempty"`
	UserID       string     `json:"userID"`
}

// CreateSessionInput is used for create Session object.
// Input was generated by ent.
type CreateSessionInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token *string `json:"token,omitempty"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips     string  `json:"ips"`
	UsersID *string `json:"usersID,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Email     string     `json:"email"`
	FirstName string     `json:"firstName"`
	LastName  string     `json:"lastName"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user bcrypt password hash
	Passwordhash           *string  `json:"passwordhash,omitempty"`
	OrganizationIDs        []string `json:"organizationIDs,omitempty"`
	SessionIDs             []string `json:"sessionIDs,omitempty"`
	GroupIDs               []string `json:"groupIDs,omitempty"`
	PersonalAccessTokenIDs []string `json:"personalAccessTokenIDs,omitempty"`
	SettingID              string   `json:"settingID"`
}

// CreateUserSettingsInput is used for create UserSettings object.
// Input was generated by ent.
type CreateUserSettingsInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// local user password recovery code generated during account creation - does not exist for oauth'd users
	RecoveryCode   *string              `json:"recoveryCode,omitempty"`
	Status         *usersettings.Status `json:"status,omitempty"`
	Role           *usersettings.Role   `json:"role,omitempty"`
	Permissions    []string             `json:"permissions,omitempty"`
	EmailConfirmed *bool                `json:"emailConfirmed,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
}

type Entitlement struct {
	ID                   string           `json:"id"`
	CreatedAt            time.Time        `json:"createdAt"`
	UpdatedAt            time.Time        `json:"updatedAt"`
	CreatedBy            *string          `json:"createdBy,omitempty"`
	UpdatedBy            *string          `json:"updatedBy,omitempty"`
	Tier                 entitlement.Tier `json:"tier"`
	StripeCustomerID     *string          `json:"stripeCustomerID,omitempty"`
	StripeSubscriptionID *string          `json:"stripeSubscriptionID,omitempty"`
	ExpiresAt            *time.Time       `json:"expiresAt,omitempty"`
	Cancelled            bool             `json:"cancelled"`
}

func (Entitlement) IsNode() {}

// A connection to a list of items.
type EntitlementConnection struct {
	// A list of edges.
	Edges []*EntitlementEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlement mutation
type EntitlementCreatePayload struct {
	// Created entitlement
	Entitlement Entitlement `json:"entitlement"`
}

// Return response for deleteEntitlement mutation
type EntitlementDeletePayload struct {
	// Deleted entitlement ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementEdge struct {
	// The item at the end of the edge.
	Node *Entitlement `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateEntitlement mutation
type EntitlementUpdatePayload struct {
	// Updated entitlement
	Entitlement Entitlement `json:"entitlement"`
}

// EntitlementWhereInput is used for filtering Entitlement objects.
// Input was generated by ent.
type EntitlementWhereInput struct {
	Not *EntitlementWhereInput   `json:"not,omitempty"`
	And []*EntitlementWhereInput `json:"and,omitempty"`
	Or  []*EntitlementWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// tier field predicates
	Tier      *entitlement.Tier  `json:"tier,omitempty"`
	TierNeq   *entitlement.Tier  `json:"tierNEQ,omitempty"`
	TierIn    []entitlement.Tier `json:"tierIn,omitempty"`
	TierNotIn []entitlement.Tier `json:"tierNotIn,omitempty"`
	// stripe_customer_id field predicates
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIDNeq          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIDGt           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIDGte          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIDLt           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIDLte          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        *bool    `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       *bool    `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIDNeq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIDGt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIDGte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIDLt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIDLte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// cancelled field predicates
	Cancelled    *bool `json:"cancelled,omitempty"`
	CancelledNeq *bool `json:"cancelledNEQ,omitempty"`
}

type Group struct {
	ID          string    `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
	CreatedBy   *string   `json:"createdBy,omitempty"`
	UpdatedBy   *string   `json:"updatedBy,omitempty"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	LogoURL     string    `json:"logoURL"`
	// The group's displayed 'friendly' name
	DisplayName string        `json:"displayName"`
	Setting     GroupSettings `json:"setting"`
	Users       []*User       `json:"users,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (Group) IsNode() {}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

type GroupSettings struct {
	ID         string                   `json:"id"`
	CreatedAt  time.Time                `json:"createdAt"`
	UpdatedAt  time.Time                `json:"updatedAt"`
	CreatedBy  *string                  `json:"createdBy,omitempty"`
	UpdatedBy  *string                  `json:"updatedBy,omitempty"`
	Visibility groupsettings.Visibility `json:"visibility"`
	JoinPolicy groupsettings.JoinPolicy `json:"joinPolicy"`
	// tags associated with the object
	Tags []string `json:"tags"`
}

func (GroupSettings) IsNode() {}

// A connection to a list of items.
type GroupSettingsConnection struct {
	// A list of edges.
	Edges []*GroupSettingsEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingsEdge struct {
	// The item at the end of the edge.
	Node *GroupSettings `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupSettingsWhereInput is used for filtering GroupSettings objects.
// Input was generated by ent.
type GroupSettingsWhereInput struct {
	Not *GroupSettingsWhereInput   `json:"not,omitempty"`
	And []*GroupSettingsWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingsWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *groupsettings.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *groupsettings.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []groupsettings.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []groupsettings.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *groupsettings.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *groupsettings.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []groupsettings.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []groupsettings.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// setting edge predicates
	HasSetting     *bool                      `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingsWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Integration struct {
	ID          string        `json:"id"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
	CreatedBy   *string       `json:"createdBy,omitempty"`
	UpdatedBy   *string       `json:"updatedBy,omitempty"`
	Name        string        `json:"name"`
	Kind        string        `json:"kind"`
	Description *string       `json:"description,omitempty"`
	SecretName  string        `json:"secretName"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (Integration) IsNode() {}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type OauthProvider struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// the provider's name
	Name string `json:"name"`
	// the client id
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle int64 `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string `json:"infoURL"`
}

func (OauthProvider) IsNode() {}

// A connection to a list of items.
type OauthProviderConnection struct {
	// A list of edges.
	Edges []*OauthProviderEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOauthprovider mutation
type OauthProviderCreatePayload struct {
	// Created oauthprovider
	OauthProvider OauthProvider `json:"OauthProvider"`
}

// Return response for deleteOauthprovider mutation
type OauthProviderDeletePayload struct {
	// Deleted oauthprovider ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OauthProviderEdge struct {
	// The item at the end of the edge.
	Node *OauthProvider `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateOauthprovider mutation
type OauthProviderUpdatePayload struct {
	// Updated oauthprovider
	OauthProvider OauthProvider `json:"OauthProvider"`
}

// OauthProviderWhereInput is used for filtering OauthProvider objects.
// Input was generated by ent.
type OauthProviderWhereInput struct {
	Not *OauthProviderWhereInput   `json:"not,omitempty"`
	And []*OauthProviderWhereInput `json:"and,omitempty"`
	Or  []*OauthProviderWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// client_secret field predicates
	ClientSecret             *string  `json:"clientSecret,omitempty"`
	ClientSecretNeq          *string  `json:"clientSecretNEQ,omitempty"`
	ClientSecretIn           []string `json:"clientSecretIn,omitempty"`
	ClientSecretNotIn        []string `json:"clientSecretNotIn,omitempty"`
	ClientSecretGt           *string  `json:"clientSecretGT,omitempty"`
	ClientSecretGte          *string  `json:"clientSecretGTE,omitempty"`
	ClientSecretLt           *string  `json:"clientSecretLT,omitempty"`
	ClientSecretLte          *string  `json:"clientSecretLTE,omitempty"`
	ClientSecretContains     *string  `json:"clientSecretContains,omitempty"`
	ClientSecretHasPrefix    *string  `json:"clientSecretHasPrefix,omitempty"`
	ClientSecretHasSuffix    *string  `json:"clientSecretHasSuffix,omitempty"`
	ClientSecretEqualFold    *string  `json:"clientSecretEqualFold,omitempty"`
	ClientSecretContainsFold *string  `json:"clientSecretContainsFold,omitempty"`
	// redirect_url field predicates
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNeq          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGt           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGte          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLt           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLte          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`
	// scopes field predicates
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNeq          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGt           *string  `json:"scopesGT,omitempty"`
	ScopesGte          *string  `json:"scopesGTE,omitempty"`
	ScopesLt           *string  `json:"scopesLT,omitempty"`
	ScopesLte          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`
	// auth_url field predicates
	AuthURL             *string  `json:"authURL,omitempty"`
	AuthURLNeq          *string  `json:"authURLNEQ,omitempty"`
	AuthURLIn           []string `json:"authURLIn,omitempty"`
	AuthURLNotIn        []string `json:"authURLNotIn,omitempty"`
	AuthURLGt           *string  `json:"authURLGT,omitempty"`
	AuthURLGte          *string  `json:"authURLGTE,omitempty"`
	AuthURLLt           *string  `json:"authURLLT,omitempty"`
	AuthURLLte          *string  `json:"authURLLTE,omitempty"`
	AuthURLContains     *string  `json:"authURLContains,omitempty"`
	AuthURLHasPrefix    *string  `json:"authURLHasPrefix,omitempty"`
	AuthURLHasSuffix    *string  `json:"authURLHasSuffix,omitempty"`
	AuthURLEqualFold    *string  `json:"authURLEqualFold,omitempty"`
	AuthURLContainsFold *string  `json:"authURLContainsFold,omitempty"`
	// token_url field predicates
	TokenURL             *string  `json:"tokenURL,omitempty"`
	TokenURLNeq          *string  `json:"tokenURLNEQ,omitempty"`
	TokenURLIn           []string `json:"tokenURLIn,omitempty"`
	TokenURLNotIn        []string `json:"tokenURLNotIn,omitempty"`
	TokenURLGt           *string  `json:"tokenURLGT,omitempty"`
	TokenURLGte          *string  `json:"tokenURLGTE,omitempty"`
	TokenURLLt           *string  `json:"tokenURLLT,omitempty"`
	TokenURLLte          *string  `json:"tokenURLLTE,omitempty"`
	TokenURLContains     *string  `json:"tokenURLContains,omitempty"`
	TokenURLHasPrefix    *string  `json:"tokenURLHasPrefix,omitempty"`
	TokenURLHasSuffix    *string  `json:"tokenURLHasSuffix,omitempty"`
	TokenURLEqualFold    *string  `json:"tokenURLEqualFold,omitempty"`
	TokenURLContainsFold *string  `json:"tokenURLContainsFold,omitempty"`
	// auth_style field predicates
	AuthStyle      *int64  `json:"authStyle,omitempty"`
	AuthStyleNeq   *int64  `json:"authStyleNEQ,omitempty"`
	AuthStyleIn    []int64 `json:"authStyleIn,omitempty"`
	AuthStyleNotIn []int64 `json:"authStyleNotIn,omitempty"`
	AuthStyleGt    *int64  `json:"authStyleGT,omitempty"`
	AuthStyleGte   *int64  `json:"authStyleGTE,omitempty"`
	AuthStyleLt    *int64  `json:"authStyleLT,omitempty"`
	AuthStyleLte   *int64  `json:"authStyleLTE,omitempty"`
	// info_url field predicates
	InfoURL             *string  `json:"infoURL,omitempty"`
	InfoURLNeq          *string  `json:"infoURLNEQ,omitempty"`
	InfoURLIn           []string `json:"infoURLIn,omitempty"`
	InfoURLNotIn        []string `json:"infoURLNotIn,omitempty"`
	InfoURLGt           *string  `json:"infoURLGT,omitempty"`
	InfoURLGte          *string  `json:"infoURLGTE,omitempty"`
	InfoURLLt           *string  `json:"infoURLLT,omitempty"`
	InfoURLLte          *string  `json:"infoURLLTE,omitempty"`
	InfoURLContains     *string  `json:"infoURLContains,omitempty"`
	InfoURLHasPrefix    *string  `json:"infoURLHasPrefix,omitempty"`
	InfoURLHasSuffix    *string  `json:"infoURLHasSuffix,omitempty"`
	InfoURLEqualFold    *string  `json:"infoURLEqualFold,omitempty"`
	InfoURLContainsFold *string  `json:"infoURLContainsFold,omitempty"`
}

type Organization struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	Name      string    `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the Organization
	Description  *string                `json:"description,omitempty"`
	Parent       *Organization          `json:"parent,omitempty"`
	Children     OrganizationConnection `json:"children"`
	Users        []*User                `json:"users,omitempty"`
	Groups       []*Group               `json:"groups,omitempty"`
	Integrations []*Integration         `json:"integrations,omitempty"`
	Setting      OrganizationSettings   `json:"setting"`
}

func (Organization) IsNode() {}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSettings struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains"`
	SsoCert       string   `json:"ssoCert"`
	SsoEntrypoint string   `json:"ssoEntrypoint"`
	SsoIssuer     string   `json:"ssoIssuer"`
	// Name of the person to contact for billing
	BillingContact string `json:"billingContact"`
	BillingEmail   string `json:"billingEmail"`
	BillingPhone   string `json:"billingPhone"`
	BillingAddress string `json:"billingAddress"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier string `json:"taxIdentifier"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
}

func (OrganizationSettings) IsNode() {}

// A connection to a list of items.
type OrganizationSettingsConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingsEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationSettingsEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSettings `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrganizationSettingsWhereInput is used for filtering OrganizationSettings objects.
// Input was generated by ent.
type OrganizationSettingsWhereInput struct {
	Not *OrganizationSettingsWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingsWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingsWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// sso_cert field predicates
	SsoCert             *string  `json:"ssoCert,omitempty"`
	SsoCertNeq          *string  `json:"ssoCertNEQ,omitempty"`
	SsoCertIn           []string `json:"ssoCertIn,omitempty"`
	SsoCertNotIn        []string `json:"ssoCertNotIn,omitempty"`
	SsoCertGt           *string  `json:"ssoCertGT,omitempty"`
	SsoCertGte          *string  `json:"ssoCertGTE,omitempty"`
	SsoCertLt           *string  `json:"ssoCertLT,omitempty"`
	SsoCertLte          *string  `json:"ssoCertLTE,omitempty"`
	SsoCertContains     *string  `json:"ssoCertContains,omitempty"`
	SsoCertHasPrefix    *string  `json:"ssoCertHasPrefix,omitempty"`
	SsoCertHasSuffix    *string  `json:"ssoCertHasSuffix,omitempty"`
	SsoCertEqualFold    *string  `json:"ssoCertEqualFold,omitempty"`
	SsoCertContainsFold *string  `json:"ssoCertContainsFold,omitempty"`
	// sso_entrypoint field predicates
	SsoEntrypoint             *string  `json:"ssoEntrypoint,omitempty"`
	SsoEntrypointNeq          *string  `json:"ssoEntrypointNEQ,omitempty"`
	SsoEntrypointIn           []string `json:"ssoEntrypointIn,omitempty"`
	SsoEntrypointNotIn        []string `json:"ssoEntrypointNotIn,omitempty"`
	SsoEntrypointGt           *string  `json:"ssoEntrypointGT,omitempty"`
	SsoEntrypointGte          *string  `json:"ssoEntrypointGTE,omitempty"`
	SsoEntrypointLt           *string  `json:"ssoEntrypointLT,omitempty"`
	SsoEntrypointLte          *string  `json:"ssoEntrypointLTE,omitempty"`
	SsoEntrypointContains     *string  `json:"ssoEntrypointContains,omitempty"`
	SsoEntrypointHasPrefix    *string  `json:"ssoEntrypointHasPrefix,omitempty"`
	SsoEntrypointHasSuffix    *string  `json:"ssoEntrypointHasSuffix,omitempty"`
	SsoEntrypointEqualFold    *string  `json:"ssoEntrypointEqualFold,omitempty"`
	SsoEntrypointContainsFold *string  `json:"ssoEntrypointContainsFold,omitempty"`
	// sso_issuer field predicates
	SsoIssuer             *string  `json:"ssoIssuer,omitempty"`
	SsoIssuerNeq          *string  `json:"ssoIssuerNEQ,omitempty"`
	SsoIssuerIn           []string `json:"ssoIssuerIn,omitempty"`
	SsoIssuerNotIn        []string `json:"ssoIssuerNotIn,omitempty"`
	SsoIssuerGt           *string  `json:"ssoIssuerGT,omitempty"`
	SsoIssuerGte          *string  `json:"ssoIssuerGTE,omitempty"`
	SsoIssuerLt           *string  `json:"ssoIssuerLT,omitempty"`
	SsoIssuerLte          *string  `json:"ssoIssuerLTE,omitempty"`
	SsoIssuerContains     *string  `json:"ssoIssuerContains,omitempty"`
	SsoIssuerHasPrefix    *string  `json:"ssoIssuerHasPrefix,omitempty"`
	SsoIssuerHasSuffix    *string  `json:"ssoIssuerHasSuffix,omitempty"`
	SsoIssuerEqualFold    *string  `json:"ssoIssuerEqualFold,omitempty"`
	SsoIssuerContainsFold *string  `json:"ssoIssuerContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// billing_address field predicates
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNeq          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGt           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGte          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLt           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLte          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNeq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                             `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingsWhereInput `json:"hasSettingWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID           string     `json:"id"`
	CreatedAt    time.Time  `json:"createdAt"`
	UpdatedAt    time.Time  `json:"updatedAt"`
	CreatedBy    *string    `json:"createdBy,omitempty"`
	UpdatedBy    *string    `json:"updatedBy,omitempty"`
	Name         string     `json:"name"`
	UserID       string     `json:"userID"`
	Abilities    []string   `json:"abilities,omitempty"`
	ExpirationAt time.Time  `json:"expirationAt"`
	LastUsedAt   *time.Time `json:"lastUsedAt,omitempty"`
	User         User       `json:"user"`
}

func (PersonalAccessToken) IsNode() {}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created PersonalAccessToken
	PersonalAccessToken PersonalAccessToken `json:"PersonalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted PersonalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated PersonalAccessToken
	PersonalAccessToken PersonalAccessToken `json:"PersonalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIDNeq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGt           *string  `json:"userIDGT,omitempty"`
	UserIDGte          *string  `json:"userIDGTE,omitempty"`
	UserIDLt           *string  `json:"userIDLT,omitempty"`
	UserIDLte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// expiration_at field predicates
	ExpirationAt      *time.Time   `json:"expirationAt,omitempty"`
	ExpirationAtNeq   *time.Time   `json:"expirationAtNEQ,omitempty"`
	ExpirationAtIn    []*time.Time `json:"expirationAtIn,omitempty"`
	ExpirationAtNotIn []*time.Time `json:"expirationAtNotIn,omitempty"`
	ExpirationAtGt    *time.Time   `json:"expirationAtGT,omitempty"`
	ExpirationAtGte   *time.Time   `json:"expirationAtGTE,omitempty"`
	ExpirationAtLt    *time.Time   `json:"expirationAtLT,omitempty"`
	ExpirationAtLte   *time.Time   `json:"expirationAtLTE,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

type RefreshToken struct {
	ID                      string    `json:"id"`
	ClientID                string    `json:"clientID"`
	Scopes                  []string  `json:"scopes,omitempty"`
	Nonce                   string    `json:"nonce"`
	ClaimsUserID            string    `json:"claimsUserID"`
	ClaimsUsername          string    `json:"claimsUsername"`
	ClaimsEmail             string    `json:"claimsEmail"`
	ClaimsEmailVerified     bool      `json:"claimsEmailVerified"`
	ClaimsGroups            []string  `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string    `json:"claimsPreferredUsername"`
	ConnectorID             string    `json:"connectorID"`
	ConnectorData           []string  `json:"connectorData,omitempty"`
	Token                   string    `json:"token"`
	ObsoleteToken           string    `json:"obsoleteToken"`
	LastUsed                time.Time `json:"lastUsed"`
}

func (RefreshToken) IsNode() {}

// RefreshTokenWhereInput is used for filtering RefreshToken objects.
// Input was generated by ent.
type RefreshTokenWhereInput struct {
	Not *RefreshTokenWhereInput   `json:"not,omitempty"`
	And []*RefreshTokenWhereInput `json:"and,omitempty"`
	Or  []*RefreshTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// nonce field predicates
	Nonce             *string  `json:"nonce,omitempty"`
	NonceNeq          *string  `json:"nonceNEQ,omitempty"`
	NonceIn           []string `json:"nonceIn,omitempty"`
	NonceNotIn        []string `json:"nonceNotIn,omitempty"`
	NonceGt           *string  `json:"nonceGT,omitempty"`
	NonceGte          *string  `json:"nonceGTE,omitempty"`
	NonceLt           *string  `json:"nonceLT,omitempty"`
	NonceLte          *string  `json:"nonceLTE,omitempty"`
	NonceContains     *string  `json:"nonceContains,omitempty"`
	NonceHasPrefix    *string  `json:"nonceHasPrefix,omitempty"`
	NonceHasSuffix    *string  `json:"nonceHasSuffix,omitempty"`
	NonceEqualFold    *string  `json:"nonceEqualFold,omitempty"`
	NonceContainsFold *string  `json:"nonceContainsFold,omitempty"`
	// claims_user_id field predicates
	ClaimsUserID             *string  `json:"claimsUserID,omitempty"`
	ClaimsUserIDNeq          *string  `json:"claimsUserIDNEQ,omitempty"`
	ClaimsUserIDIn           []string `json:"claimsUserIDIn,omitempty"`
	ClaimsUserIDNotIn        []string `json:"claimsUserIDNotIn,omitempty"`
	ClaimsUserIDGt           *string  `json:"claimsUserIDGT,omitempty"`
	ClaimsUserIDGte          *string  `json:"claimsUserIDGTE,omitempty"`
	ClaimsUserIDLt           *string  `json:"claimsUserIDLT,omitempty"`
	ClaimsUserIDLte          *string  `json:"claimsUserIDLTE,omitempty"`
	ClaimsUserIDContains     *string  `json:"claimsUserIDContains,omitempty"`
	ClaimsUserIDHasPrefix    *string  `json:"claimsUserIDHasPrefix,omitempty"`
	ClaimsUserIDHasSuffix    *string  `json:"claimsUserIDHasSuffix,omitempty"`
	ClaimsUserIDEqualFold    *string  `json:"claimsUserIDEqualFold,omitempty"`
	ClaimsUserIDContainsFold *string  `json:"claimsUserIDContainsFold,omitempty"`
	// claims_username field predicates
	ClaimsUsername             *string  `json:"claimsUsername,omitempty"`
	ClaimsUsernameNeq          *string  `json:"claimsUsernameNEQ,omitempty"`
	ClaimsUsernameIn           []string `json:"claimsUsernameIn,omitempty"`
	ClaimsUsernameNotIn        []string `json:"claimsUsernameNotIn,omitempty"`
	ClaimsUsernameGt           *string  `json:"claimsUsernameGT,omitempty"`
	ClaimsUsernameGte          *string  `json:"claimsUsernameGTE,omitempty"`
	ClaimsUsernameLt           *string  `json:"claimsUsernameLT,omitempty"`
	ClaimsUsernameLte          *string  `json:"claimsUsernameLTE,omitempty"`
	ClaimsUsernameContains     *string  `json:"claimsUsernameContains,omitempty"`
	ClaimsUsernameHasPrefix    *string  `json:"claimsUsernameHasPrefix,omitempty"`
	ClaimsUsernameHasSuffix    *string  `json:"claimsUsernameHasSuffix,omitempty"`
	ClaimsUsernameEqualFold    *string  `json:"claimsUsernameEqualFold,omitempty"`
	ClaimsUsernameContainsFold *string  `json:"claimsUsernameContainsFold,omitempty"`
	// claims_email field predicates
	ClaimsEmail             *string  `json:"claimsEmail,omitempty"`
	ClaimsEmailNeq          *string  `json:"claimsEmailNEQ,omitempty"`
	ClaimsEmailIn           []string `json:"claimsEmailIn,omitempty"`
	ClaimsEmailNotIn        []string `json:"claimsEmailNotIn,omitempty"`
	ClaimsEmailGt           *string  `json:"claimsEmailGT,omitempty"`
	ClaimsEmailGte          *string  `json:"claimsEmailGTE,omitempty"`
	ClaimsEmailLt           *string  `json:"claimsEmailLT,omitempty"`
	ClaimsEmailLte          *string  `json:"claimsEmailLTE,omitempty"`
	ClaimsEmailContains     *string  `json:"claimsEmailContains,omitempty"`
	ClaimsEmailHasPrefix    *string  `json:"claimsEmailHasPrefix,omitempty"`
	ClaimsEmailHasSuffix    *string  `json:"claimsEmailHasSuffix,omitempty"`
	ClaimsEmailEqualFold    *string  `json:"claimsEmailEqualFold,omitempty"`
	ClaimsEmailContainsFold *string  `json:"claimsEmailContainsFold,omitempty"`
	// claims_email_verified field predicates
	ClaimsEmailVerified    *bool `json:"claimsEmailVerified,omitempty"`
	ClaimsEmailVerifiedNeq *bool `json:"claimsEmailVerifiedNEQ,omitempty"`
	// claims_preferred_username field predicates
	ClaimsPreferredUsername             *string  `json:"claimsPreferredUsername,omitempty"`
	ClaimsPreferredUsernameNeq          *string  `json:"claimsPreferredUsernameNEQ,omitempty"`
	ClaimsPreferredUsernameIn           []string `json:"claimsPreferredUsernameIn,omitempty"`
	ClaimsPreferredUsernameNotIn        []string `json:"claimsPreferredUsernameNotIn,omitempty"`
	ClaimsPreferredUsernameGt           *string  `json:"claimsPreferredUsernameGT,omitempty"`
	ClaimsPreferredUsernameGte          *string  `json:"claimsPreferredUsernameGTE,omitempty"`
	ClaimsPreferredUsernameLt           *string  `json:"claimsPreferredUsernameLT,omitempty"`
	ClaimsPreferredUsernameLte          *string  `json:"claimsPreferredUsernameLTE,omitempty"`
	ClaimsPreferredUsernameContains     *string  `json:"claimsPreferredUsernameContains,omitempty"`
	ClaimsPreferredUsernameHasPrefix    *string  `json:"claimsPreferredUsernameHasPrefix,omitempty"`
	ClaimsPreferredUsernameHasSuffix    *string  `json:"claimsPreferredUsernameHasSuffix,omitempty"`
	ClaimsPreferredUsernameEqualFold    *string  `json:"claimsPreferredUsernameEqualFold,omitempty"`
	ClaimsPreferredUsernameContainsFold *string  `json:"claimsPreferredUsernameContainsFold,omitempty"`
	// connector_id field predicates
	ConnectorID             *string  `json:"connectorID,omitempty"`
	ConnectorIDNeq          *string  `json:"connectorIDNEQ,omitempty"`
	ConnectorIDIn           []string `json:"connectorIDIn,omitempty"`
	ConnectorIDNotIn        []string `json:"connectorIDNotIn,omitempty"`
	ConnectorIDGt           *string  `json:"connectorIDGT,omitempty"`
	ConnectorIDGte          *string  `json:"connectorIDGTE,omitempty"`
	ConnectorIDLt           *string  `json:"connectorIDLT,omitempty"`
	ConnectorIDLte          *string  `json:"connectorIDLTE,omitempty"`
	ConnectorIDContains     *string  `json:"connectorIDContains,omitempty"`
	ConnectorIDHasPrefix    *string  `json:"connectorIDHasPrefix,omitempty"`
	ConnectorIDHasSuffix    *string  `json:"connectorIDHasSuffix,omitempty"`
	ConnectorIDEqualFold    *string  `json:"connectorIDEqualFold,omitempty"`
	ConnectorIDContainsFold *string  `json:"connectorIDContainsFold,omitempty"`
	// token field predicates
	Token             *string  `json:"token,omitempty"`
	TokenNeq          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGt           *string  `json:"tokenGT,omitempty"`
	TokenGte          *string  `json:"tokenGTE,omitempty"`
	TokenLt           *string  `json:"tokenLT,omitempty"`
	TokenLte          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`
	// obsolete_token field predicates
	ObsoleteToken             *string  `json:"obsoleteToken,omitempty"`
	ObsoleteTokenNeq          *string  `json:"obsoleteTokenNEQ,omitempty"`
	ObsoleteTokenIn           []string `json:"obsoleteTokenIn,omitempty"`
	ObsoleteTokenNotIn        []string `json:"obsoleteTokenNotIn,omitempty"`
	ObsoleteTokenGt           *string  `json:"obsoleteTokenGT,omitempty"`
	ObsoleteTokenGte          *string  `json:"obsoleteTokenGTE,omitempty"`
	ObsoleteTokenLt           *string  `json:"obsoleteTokenLT,omitempty"`
	ObsoleteTokenLte          *string  `json:"obsoleteTokenLTE,omitempty"`
	ObsoleteTokenContains     *string  `json:"obsoleteTokenContains,omitempty"`
	ObsoleteTokenHasPrefix    *string  `json:"obsoleteTokenHasPrefix,omitempty"`
	ObsoleteTokenHasSuffix    *string  `json:"obsoleteTokenHasSuffix,omitempty"`
	ObsoleteTokenEqualFold    *string  `json:"obsoleteTokenEqualFold,omitempty"`
	ObsoleteTokenContainsFold *string  `json:"obsoleteTokenContainsFold,omitempty"`
	// last_used field predicates
	LastUsed      *time.Time   `json:"lastUsed,omitempty"`
	LastUsedNeq   *time.Time   `json:"lastUsedNEQ,omitempty"`
	LastUsedIn    []*time.Time `json:"lastUsedIn,omitempty"`
	LastUsedNotIn []*time.Time `json:"lastUsedNotIn,omitempty"`
	LastUsedGt    *time.Time   `json:"lastUsedGT,omitempty"`
	LastUsedGte   *time.Time   `json:"lastUsedGTE,omitempty"`
	LastUsedLt    *time.Time   `json:"lastUsedLT,omitempty"`
	LastUsedLte   *time.Time   `json:"lastUsedLTE,omitempty"`
}

type Session struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token string `json:"token"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips string `json:"ips"`
	// Sessions belong to users
	Users *User `json:"users,omitempty"`
}

func (Session) IsNode() {}

// A connection to a list of items.
type SessionConnection struct {
	// A list of edges.
	Edges []*SessionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSession mutation
type SessionCreatePayload struct {
	// Created session
	Session Session `json:"session"`
}

// Return response for deleteSession mutation
type SessionDeletePayload struct {
	// Deleted session ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SessionEdge struct {
	// The item at the end of the edge.
	Node *Session `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateSession mutation
type SessionUpdatePayload struct {
	// Updated session
	Session Session `json:"session"`
}

// SessionWhereInput is used for filtering Session objects.
// Input was generated by ent.
type SessionWhereInput struct {
	Not *SessionWhereInput   `json:"not,omitempty"`
	And []*SessionWhereInput `json:"and,omitempty"`
	Or  []*SessionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// type field predicates
	Type      *session.Type  `json:"type,omitempty"`
	TypeNeq   *session.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []session.Type `json:"typeIn,omitempty"`
	TypeNotIn []session.Type `json:"typeNotIn,omitempty"`
	// disabled field predicates
	Disabled    *bool `json:"disabled,omitempty"`
	DisabledNeq *bool `json:"disabledNEQ,omitempty"`
	// token field predicates
	Token             *string  `json:"token,omitempty"`
	TokenNeq          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGt           *string  `json:"tokenGT,omitempty"`
	TokenGte          *string  `json:"tokenGTE,omitempty"`
	TokenLt           *string  `json:"tokenLT,omitempty"`
	TokenLte          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`
	// user_agent field predicates
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNeq          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGt           *string  `json:"userAgentGT,omitempty"`
	UserAgentGte          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLt           *string  `json:"userAgentLT,omitempty"`
	UserAgentLte          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentIsNil        *bool    `json:"userAgentIsNil,omitempty"`
	UserAgentNotNil       *bool    `json:"userAgentNotNil,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`
	// ips field predicates
	Ips             *string  `json:"ips,omitempty"`
	IpsNeq          *string  `json:"ipsNEQ,omitempty"`
	IpsIn           []string `json:"ipsIn,omitempty"`
	IpsNotIn        []string `json:"ipsNotIn,omitempty"`
	IpsGt           *string  `json:"ipsGT,omitempty"`
	IpsGte          *string  `json:"ipsGTE,omitempty"`
	IpsLt           *string  `json:"ipsLT,omitempty"`
	IpsLte          *string  `json:"ipsLTE,omitempty"`
	IpsContains     *string  `json:"ipsContains,omitempty"`
	IpsHasPrefix    *string  `json:"ipsHasPrefix,omitempty"`
	IpsHasSuffix    *string  `json:"ipsHasSuffix,omitempty"`
	IpsEqualFold    *string  `json:"ipsEqualFold,omitempty"`
	IpsContainsFold *string  `json:"ipsContainsFold,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// UpdateEntitlementInput is used for update Entitlement object.
// Input was generated by ent.
type UpdateEntitlementInput struct {
	UpdatedAt                 *time.Time        `json:"updatedAt,omitempty"`
	CreatedBy                 *string           `json:"createdBy,omitempty"`
	ClearCreatedBy            *bool             `json:"clearCreatedBy,omitempty"`
	UpdatedBy                 *string           `json:"updatedBy,omitempty"`
	ClearUpdatedBy            *bool             `json:"clearUpdatedBy,omitempty"`
	Tier                      *entitlement.Tier `json:"tier,omitempty"`
	StripeCustomerID          *string           `json:"stripeCustomerID,omitempty"`
	ClearStripeCustomerID     *bool             `json:"clearStripeCustomerID,omitempty"`
	StripeSubscriptionID      *string           `json:"stripeSubscriptionID,omitempty"`
	ClearStripeSubscriptionID *bool             `json:"clearStripeSubscriptionID,omitempty"`
	ExpiresAt                 *time.Time        `json:"expiresAt,omitempty"`
	ClearExpiresAt            *bool             `json:"clearExpiresAt,omitempty"`
	Cancelled                 *bool             `json:"cancelled,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	Description    *string    `json:"description,omitempty"`
	LogoURL        *string    `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName   *string  `json:"displayName,omitempty"`
	SettingID     *string  `json:"settingID,omitempty"`
	AddUserIDs    []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs []string `json:"removeUserIDs,omitempty"`
	ClearUsers    *bool    `json:"clearUsers,omitempty"`
	OwnerID       *string  `json:"ownerID,omitempty"`
	ClearOwner    *bool    `json:"clearOwner,omitempty"`
}

// UpdateGroupSettingsInput is used for update GroupSettings object.
// Input was generated by ent.
type UpdateGroupSettingsInput struct {
	UpdatedAt      *time.Time                `json:"updatedAt,omitempty"`
	CreatedBy      *string                   `json:"createdBy,omitempty"`
	ClearCreatedBy *bool                     `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string                   `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool                     `json:"clearUpdatedBy,omitempty"`
	Visibility     *groupsettings.Visibility `json:"visibility,omitempty"`
	JoinPolicy     *groupsettings.JoinPolicy `json:"joinPolicy,omitempty"`
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
	CreatedBy        *string    `json:"createdBy,omitempty"`
	ClearCreatedBy   *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy        *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy   *bool      `json:"clearUpdatedBy,omitempty"`
	Name             *string    `json:"name,omitempty"`
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	OwnerID          *string    `json:"ownerID,omitempty"`
	ClearOwner       *bool      `json:"clearOwner,omitempty"`
}

// UpdateOauthProviderInput is used for update OauthProvider object.
// Input was generated by ent.
type UpdateOauthProviderInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// the provider's name
	Name *string `json:"name,omitempty"`
	// the client id
	ClientID *string `json:"clientID,omitempty"`
	// the client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// the redirect url
	RedirectURL *string `json:"redirectURL,omitempty"`
	// the scopes
	Scopes *string `json:"scopes,omitempty"`
	// the auth url of the provider
	AuthURL *string `json:"authURL,omitempty"`
	// the token url of the provider
	TokenURL *string `json:"tokenURL,omitempty"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle *int64 `json:"authStyle,omitempty"`
	// the URL to request user information by token
	InfoURL *string `json:"infoURL,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the Organization
	Description          *string  `json:"description,omitempty"`
	ClearDescription     *bool    `json:"clearDescription,omitempty"`
	AddUserIDs           []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs        []string `json:"removeUserIDs,omitempty"`
	ClearUsers           *bool    `json:"clearUsers,omitempty"`
	AddGroupIDs          []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs       []string `json:"removeGroupIDs,omitempty"`
	ClearGroups          *bool    `json:"clearGroups,omitempty"`
	AddIntegrationIDs    []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool    `json:"clearIntegrations,omitempty"`
	SettingID            *string  `json:"settingID,omitempty"`
}

// UpdateOrganizationSettingsInput is used for update OrganizationSettings object.
// Input was generated by ent.
type UpdateOrganizationSettingsInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	SsoCert       *string  `json:"ssoCert,omitempty"`
	SsoEntrypoint *string  `json:"ssoEntrypoint,omitempty"`
	SsoIssuer     *string  `json:"ssoIssuer,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	BillingEmail   *string `json:"billingEmail,omitempty"`
	BillingPhone   *string `json:"billingPhone,omitempty"`
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	UpdatedAt       *time.Time `json:"updatedAt,omitempty"`
	CreatedBy       *string    `json:"createdBy,omitempty"`
	ClearCreatedBy  *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy       *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy  *bool      `json:"clearUpdatedBy,omitempty"`
	Name            *string    `json:"name,omitempty"`
	Token           *string    `json:"token,omitempty"`
	Abilities       []string   `json:"abilities,omitempty"`
	AppendAbilities []string   `json:"appendAbilities,omitempty"`
	ClearAbilities  *bool      `json:"clearAbilities,omitempty"`
	ExpirationAt    *time.Time `json:"expirationAt,omitempty"`
	LastUsedAt      *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt *bool      `json:"clearLastUsedAt,omitempty"`
	UserID          *string    `json:"userID,omitempty"`
}

// UpdateSessionInput is used for update Session object.
// Input was generated by ent.
type UpdateSessionInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// The session may be disabled by the user or by automatic security policy
	Disabled *bool `json:"disabled,omitempty"`
	// The last known user-agent
	UserAgent      *string `json:"userAgent,omitempty"`
	ClearUserAgent *bool   `json:"clearUserAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips        *string `json:"ips,omitempty"`
	UsersID    *string `json:"usersID,omitempty"`
	ClearUsers *bool   `json:"clearUsers,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Email          *string    `json:"email,omitempty"`
	FirstName      *string    `json:"firstName,omitempty"`
	LastName       *string    `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile      *string `json:"avatarLocalFile,omitempty"`
	ClearAvatarLocalFile *bool   `json:"clearAvatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// user bcrypt password hash
	Passwordhash                 *string  `json:"passwordhash,omitempty"`
	ClearPasswordHash            *bool    `json:"clearPasswordHash,omitempty"`
	AddOrganizationIDs           []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations           *bool    `json:"clearOrganizations,omitempty"`
	AddSessionIDs                []string `json:"addSessionIDs,omitempty"`
	RemoveSessionIDs             []string `json:"removeSessionIDs,omitempty"`
	ClearSessions                *bool    `json:"clearSessions,omitempty"`
	AddGroupIDs                  []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string `json:"removeGroupIDs,omitempty"`
	ClearGroups                  *bool    `json:"clearGroups,omitempty"`
	AddPersonalAccessTokenIDs    []string `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens    *bool    `json:"clearPersonalAccessTokens,omitempty"`
	SettingID                    *string  `json:"settingID,omitempty"`
}

// UpdateUserSettingsInput is used for update UserSettings object.
// Input was generated by ent.
type UpdateUserSettingsInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// local user password recovery code generated during account creation - does not exist for oauth'd users
	RecoveryCode      *string              `json:"recoveryCode,omitempty"`
	ClearRecoveryCode *bool                `json:"clearRecoveryCode,omitempty"`
	Status            *usersettings.Status `json:"status,omitempty"`
	Role              *usersettings.Role   `json:"role,omitempty"`
	Permissions       []string             `json:"permissions,omitempty"`
	AppendPermissions []string             `json:"appendPermissions,omitempty"`
	EmailConfirmed    *bool                `json:"emailConfirmed,omitempty"`
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
}

type User struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen             *time.Time             `json:"lastSeen,omitempty"`
	Organizations        []*Organization        `json:"organizations,omitempty"`
	Sessions             []*Session             `json:"sessions,omitempty"`
	Groups               []*Group               `json:"groups,omitempty"`
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
	Setting              UserSettings           `json:"setting"`
}

func (User) IsNode() {}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSettings struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt    *time.Time          `json:"suspendedAt,omitempty"`
	Status         usersettings.Status `json:"status"`
	Role           usersettings.Role   `json:"role"`
	Permissions    []string            `json:"permissions"`
	EmailConfirmed bool                `json:"emailConfirmed"`
	// tags associated with the object
	Tags []string `json:"tags"`
}

func (UserSettings) IsNode() {}

// A connection to a list of items.
type UserSettingsConnection struct {
	// A list of edges.
	Edges []*UserSettingsEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSettings mutation
type UserSettingsCreatePayload struct {
	// Created UserSettings
	UserSettings UserSettings `json:"UserSettings"`
}

// Return response for deleteUserSettings mutation
type UserSettingsDeletePayload struct {
	// Deleted UserSettings ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserSettingsEdge struct {
	// The item at the end of the edge.
	Node *UserSettings `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateUserSettings mutation
type UserSettingsUpdatePayload struct {
	// Updated UserSettings
	UserSettings UserSettings `json:"UserSettings"`
}

// UserSettingsWhereInput is used for filtering UserSettings objects.
// Input was generated by ent.
type UserSettingsWhereInput struct {
	Not *UserSettingsWhereInput   `json:"not,omitempty"`
	And []*UserSettingsWhereInput `json:"and,omitempty"`
	Or  []*UserSettingsWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *usersettings.Status  `json:"status,omitempty"`
	StatusNeq   *usersettings.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []usersettings.Status `json:"statusIn,omitempty"`
	StatusNotIn []usersettings.Status `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *usersettings.Role  `json:"role,omitempty"`
	RoleNeq   *usersettings.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []usersettings.Role `json:"roleIn,omitempty"`
	RoleNotIn []usersettings.Role `json:"roleNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// sessions edge predicates
	HasSessions     *bool                `json:"hasSessions,omitempty"`
	HasSessionsWith []*SessionWhereInput `json:"hasSessionsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingsWhereInput `json:"hasSettingWith,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldName IntegrationOrderField = "name"
	IntegrationOrderFieldKind IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
