// Code generated by enthistory, DO NOT EDIT.
// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/datumforge/datum/internal/ent/generated/emailverificationtokenhistory"
	"github.com/datumforge/datum/internal/ent/generated/entitlementhistory"
	"github.com/datumforge/datum/internal/ent/generated/grouphistory"
	"github.com/datumforge/datum/internal/ent/generated/groupsettinghistory"
	"github.com/datumforge/datum/internal/ent/generated/integrationhistory"
	"github.com/datumforge/datum/internal/ent/generated/oauthproviderhistory"
	"github.com/datumforge/datum/internal/ent/generated/ohauthtootokenhistory"
	"github.com/datumforge/datum/internal/ent/generated/organizationhistory"
	"github.com/datumforge/datum/internal/ent/generated/organizationsettinghistory"
	"github.com/datumforge/datum/internal/ent/generated/passwordresettokenhistory"
	"github.com/datumforge/datum/internal/ent/generated/personalaccesstokenhistory"
	"github.com/datumforge/datum/internal/ent/generated/sessionhistory"
	"github.com/datumforge/datum/internal/ent/generated/userhistory"
	"github.com/datumforge/datum/internal/ent/generated/usersettinghistory"
	"github.com/flume/enthistory"
)

type Change struct {
	FieldName string
	Old       any
	New       any
}

func NewChange(fieldName string, old, new any) Change {
	return Change{
		FieldName: fieldName,
		Old:       old,
		New:       new,
	}
}

type HistoryDiff[T any] struct {
	Old     *T
	New     *T
	Changes []Change
}

var (
	MismatchedRefError    = errors.New("cannot take diff of histories with different Refs")
	IdenticalHistoryError = errors.New("cannot take diff of identical history")
)

func (evth *EmailVerificationTokenHistory) changes(new *EmailVerificationTokenHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(evth.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldCreatedAt, evth.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(evth.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldUpdatedAt, evth.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(evth.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldCreatedBy, evth.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(evth.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldDeletedAt, evth.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(evth.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldDeletedBy, evth.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(evth.Token, new.Token) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldToken, evth.Token, new.Token))
	}
	if !reflect.DeepEqual(evth.TTL, new.TTL) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldTTL, evth.TTL, new.TTL))
	}
	if !reflect.DeepEqual(evth.Email, new.Email) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldEmail, evth.Email, new.Email))
	}
	if !reflect.DeepEqual(evth.Secret, new.Secret) {
		changes = append(changes, NewChange(emailverificationtokenhistory.FieldSecret, evth.Secret, new.Secret))
	}
	return changes
}

func (evth *EmailVerificationTokenHistory) Diff(history *EmailVerificationTokenHistory) (*HistoryDiff[EmailVerificationTokenHistory], error) {
	if evth.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	evthUnix, historyUnix := evth.HistoryTime.Unix(), history.HistoryTime.Unix()
	evthOlder := evthUnix < historyUnix || (evthUnix == historyUnix && evth.ID < history.ID)
	historyOlder := evthUnix > historyUnix || (evthUnix == historyUnix && evth.ID > history.ID)

	if evthOlder {
		return &HistoryDiff[EmailVerificationTokenHistory]{
			Old:     evth,
			New:     history,
			Changes: evth.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EmailVerificationTokenHistory]{
			Old:     history,
			New:     evth,
			Changes: history.changes(evth),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (eh *EntitlementHistory) changes(new *EntitlementHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(eh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(entitlementhistory.FieldCreatedAt, eh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(eh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(entitlementhistory.FieldUpdatedAt, eh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(eh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(entitlementhistory.FieldCreatedBy, eh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(eh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(entitlementhistory.FieldDeletedAt, eh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(eh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(entitlementhistory.FieldDeletedBy, eh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(eh.Tier, new.Tier) {
		changes = append(changes, NewChange(entitlementhistory.FieldTier, eh.Tier, new.Tier))
	}
	if !reflect.DeepEqual(eh.ExternalCustomerID, new.ExternalCustomerID) {
		changes = append(changes, NewChange(entitlementhistory.FieldExternalCustomerID, eh.ExternalCustomerID, new.ExternalCustomerID))
	}
	if !reflect.DeepEqual(eh.ExternalSubscriptionID, new.ExternalSubscriptionID) {
		changes = append(changes, NewChange(entitlementhistory.FieldExternalSubscriptionID, eh.ExternalSubscriptionID, new.ExternalSubscriptionID))
	}
	if !reflect.DeepEqual(eh.Expires, new.Expires) {
		changes = append(changes, NewChange(entitlementhistory.FieldExpires, eh.Expires, new.Expires))
	}
	if !reflect.DeepEqual(eh.ExpiresAt, new.ExpiresAt) {
		changes = append(changes, NewChange(entitlementhistory.FieldExpiresAt, eh.ExpiresAt, new.ExpiresAt))
	}
	if !reflect.DeepEqual(eh.Cancelled, new.Cancelled) {
		changes = append(changes, NewChange(entitlementhistory.FieldCancelled, eh.Cancelled, new.Cancelled))
	}
	return changes
}

func (eh *EntitlementHistory) Diff(history *EntitlementHistory) (*HistoryDiff[EntitlementHistory], error) {
	if eh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ehUnix, historyUnix := eh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ehOlder := ehUnix < historyUnix || (ehUnix == historyUnix && eh.ID < history.ID)
	historyOlder := ehUnix > historyUnix || (ehUnix == historyUnix && eh.ID > history.ID)

	if ehOlder {
		return &HistoryDiff[EntitlementHistory]{
			Old:     eh,
			New:     history,
			Changes: eh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EntitlementHistory]{
			Old:     history,
			New:     eh,
			Changes: history.changes(eh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (gh *GroupHistory) changes(new *GroupHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(gh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(grouphistory.FieldCreatedAt, gh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(gh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(grouphistory.FieldUpdatedAt, gh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(gh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(grouphistory.FieldCreatedBy, gh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(gh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(grouphistory.FieldDeletedAt, gh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(gh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(grouphistory.FieldDeletedBy, gh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(gh.Name, new.Name) {
		changes = append(changes, NewChange(grouphistory.FieldName, gh.Name, new.Name))
	}
	if !reflect.DeepEqual(gh.Description, new.Description) {
		changes = append(changes, NewChange(grouphistory.FieldDescription, gh.Description, new.Description))
	}
	if !reflect.DeepEqual(gh.GravatarLogoURL, new.GravatarLogoURL) {
		changes = append(changes, NewChange(grouphistory.FieldGravatarLogoURL, gh.GravatarLogoURL, new.GravatarLogoURL))
	}
	if !reflect.DeepEqual(gh.LogoURL, new.LogoURL) {
		changes = append(changes, NewChange(grouphistory.FieldLogoURL, gh.LogoURL, new.LogoURL))
	}
	if !reflect.DeepEqual(gh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(grouphistory.FieldDisplayName, gh.DisplayName, new.DisplayName))
	}
	return changes
}

func (gh *GroupHistory) Diff(history *GroupHistory) (*HistoryDiff[GroupHistory], error) {
	if gh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ghUnix, historyUnix := gh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ghOlder := ghUnix < historyUnix || (ghUnix == historyUnix && gh.ID < history.ID)
	historyOlder := ghUnix > historyUnix || (ghUnix == historyUnix && gh.ID > history.ID)

	if ghOlder {
		return &HistoryDiff[GroupHistory]{
			Old:     gh,
			New:     history,
			Changes: gh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupHistory]{
			Old:     history,
			New:     gh,
			Changes: history.changes(gh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (gsh *GroupSettingHistory) changes(new *GroupSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(gsh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldCreatedAt, gsh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(gsh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldUpdatedAt, gsh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(gsh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldCreatedBy, gsh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(gsh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldDeletedAt, gsh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(gsh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldDeletedBy, gsh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(gsh.Visibility, new.Visibility) {
		changes = append(changes, NewChange(groupsettinghistory.FieldVisibility, gsh.Visibility, new.Visibility))
	}
	if !reflect.DeepEqual(gsh.JoinPolicy, new.JoinPolicy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldJoinPolicy, gsh.JoinPolicy, new.JoinPolicy))
	}
	if !reflect.DeepEqual(gsh.Tags, new.Tags) {
		changes = append(changes, NewChange(groupsettinghistory.FieldTags, gsh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(gsh.SyncToSlack, new.SyncToSlack) {
		changes = append(changes, NewChange(groupsettinghistory.FieldSyncToSlack, gsh.SyncToSlack, new.SyncToSlack))
	}
	if !reflect.DeepEqual(gsh.SyncToGithub, new.SyncToGithub) {
		changes = append(changes, NewChange(groupsettinghistory.FieldSyncToGithub, gsh.SyncToGithub, new.SyncToGithub))
	}
	return changes
}

func (gsh *GroupSettingHistory) Diff(history *GroupSettingHistory) (*HistoryDiff[GroupSettingHistory], error) {
	if gsh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	gshUnix, historyUnix := gsh.HistoryTime.Unix(), history.HistoryTime.Unix()
	gshOlder := gshUnix < historyUnix || (gshUnix == historyUnix && gsh.ID < history.ID)
	historyOlder := gshUnix > historyUnix || (gshUnix == historyUnix && gsh.ID > history.ID)

	if gshOlder {
		return &HistoryDiff[GroupSettingHistory]{
			Old:     gsh,
			New:     history,
			Changes: gsh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupSettingHistory]{
			Old:     history,
			New:     gsh,
			Changes: history.changes(gsh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (ih *IntegrationHistory) changes(new *IntegrationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ih.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldCreatedAt, ih.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ih.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldUpdatedAt, ih.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ih.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(integrationhistory.FieldCreatedBy, ih.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ih.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldDeletedAt, ih.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ih.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(integrationhistory.FieldDeletedBy, ih.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ih.Name, new.Name) {
		changes = append(changes, NewChange(integrationhistory.FieldName, ih.Name, new.Name))
	}
	if !reflect.DeepEqual(ih.Description, new.Description) {
		changes = append(changes, NewChange(integrationhistory.FieldDescription, ih.Description, new.Description))
	}
	if !reflect.DeepEqual(ih.Kind, new.Kind) {
		changes = append(changes, NewChange(integrationhistory.FieldKind, ih.Kind, new.Kind))
	}
	if !reflect.DeepEqual(ih.SecretName, new.SecretName) {
		changes = append(changes, NewChange(integrationhistory.FieldSecretName, ih.SecretName, new.SecretName))
	}
	return changes
}

func (ih *IntegrationHistory) Diff(history *IntegrationHistory) (*HistoryDiff[IntegrationHistory], error) {
	if ih.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ihUnix, historyUnix := ih.HistoryTime.Unix(), history.HistoryTime.Unix()
	ihOlder := ihUnix < historyUnix || (ihUnix == historyUnix && ih.ID < history.ID)
	historyOlder := ihUnix > historyUnix || (ihUnix == historyUnix && ih.ID > history.ID)

	if ihOlder {
		return &HistoryDiff[IntegrationHistory]{
			Old:     ih,
			New:     history,
			Changes: ih.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[IntegrationHistory]{
			Old:     history,
			New:     ih,
			Changes: history.changes(ih),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (oph *OauthProviderHistory) changes(new *OauthProviderHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(oph.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldCreatedAt, oph.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(oph.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldUpdatedAt, oph.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(oph.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldCreatedBy, oph.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(oph.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldDeletedAt, oph.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(oph.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldDeletedBy, oph.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(oph.Name, new.Name) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldName, oph.Name, new.Name))
	}
	if !reflect.DeepEqual(oph.ClientID, new.ClientID) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldClientID, oph.ClientID, new.ClientID))
	}
	if !reflect.DeepEqual(oph.ClientSecret, new.ClientSecret) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldClientSecret, oph.ClientSecret, new.ClientSecret))
	}
	if !reflect.DeepEqual(oph.RedirectURL, new.RedirectURL) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldRedirectURL, oph.RedirectURL, new.RedirectURL))
	}
	if !reflect.DeepEqual(oph.Scopes, new.Scopes) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldScopes, oph.Scopes, new.Scopes))
	}
	if !reflect.DeepEqual(oph.AuthURL, new.AuthURL) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldAuthURL, oph.AuthURL, new.AuthURL))
	}
	if !reflect.DeepEqual(oph.TokenURL, new.TokenURL) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldTokenURL, oph.TokenURL, new.TokenURL))
	}
	if !reflect.DeepEqual(oph.AuthStyle, new.AuthStyle) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldAuthStyle, oph.AuthStyle, new.AuthStyle))
	}
	if !reflect.DeepEqual(oph.InfoURL, new.InfoURL) {
		changes = append(changes, NewChange(oauthproviderhistory.FieldInfoURL, oph.InfoURL, new.InfoURL))
	}
	return changes
}

func (oph *OauthProviderHistory) Diff(history *OauthProviderHistory) (*HistoryDiff[OauthProviderHistory], error) {
	if oph.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ophUnix, historyUnix := oph.HistoryTime.Unix(), history.HistoryTime.Unix()
	ophOlder := ophUnix < historyUnix || (ophUnix == historyUnix && oph.ID < history.ID)
	historyOlder := ophUnix > historyUnix || (ophUnix == historyUnix && oph.ID > history.ID)

	if ophOlder {
		return &HistoryDiff[OauthProviderHistory]{
			Old:     oph,
			New:     history,
			Changes: oph.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OauthProviderHistory]{
			Old:     history,
			New:     oph,
			Changes: history.changes(oph),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (oatth *OhAuthTooTokenHistory) changes(new *OhAuthTooTokenHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(oatth.ClientID, new.ClientID) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClientID, oatth.ClientID, new.ClientID))
	}
	if !reflect.DeepEqual(oatth.Scopes, new.Scopes) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldScopes, oatth.Scopes, new.Scopes))
	}
	if !reflect.DeepEqual(oatth.Nonce, new.Nonce) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldNonce, oatth.Nonce, new.Nonce))
	}
	if !reflect.DeepEqual(oatth.ClaimsUserID, new.ClaimsUserID) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClaimsUserID, oatth.ClaimsUserID, new.ClaimsUserID))
	}
	if !reflect.DeepEqual(oatth.ClaimsUsername, new.ClaimsUsername) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClaimsUsername, oatth.ClaimsUsername, new.ClaimsUsername))
	}
	if !reflect.DeepEqual(oatth.ClaimsEmail, new.ClaimsEmail) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClaimsEmail, oatth.ClaimsEmail, new.ClaimsEmail))
	}
	if !reflect.DeepEqual(oatth.ClaimsEmailVerified, new.ClaimsEmailVerified) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClaimsEmailVerified, oatth.ClaimsEmailVerified, new.ClaimsEmailVerified))
	}
	if !reflect.DeepEqual(oatth.ClaimsGroups, new.ClaimsGroups) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClaimsGroups, oatth.ClaimsGroups, new.ClaimsGroups))
	}
	if !reflect.DeepEqual(oatth.ClaimsPreferredUsername, new.ClaimsPreferredUsername) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldClaimsPreferredUsername, oatth.ClaimsPreferredUsername, new.ClaimsPreferredUsername))
	}
	if !reflect.DeepEqual(oatth.ConnectorID, new.ConnectorID) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldConnectorID, oatth.ConnectorID, new.ConnectorID))
	}
	if !reflect.DeepEqual(oatth.ConnectorData, new.ConnectorData) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldConnectorData, oatth.ConnectorData, new.ConnectorData))
	}
	if !reflect.DeepEqual(oatth.LastUsed, new.LastUsed) {
		changes = append(changes, NewChange(ohauthtootokenhistory.FieldLastUsed, oatth.LastUsed, new.LastUsed))
	}
	return changes
}

func (oatth *OhAuthTooTokenHistory) Diff(history *OhAuthTooTokenHistory) (*HistoryDiff[OhAuthTooTokenHistory], error) {
	if oatth.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	oatthUnix, historyUnix := oatth.HistoryTime.Unix(), history.HistoryTime.Unix()
	oatthOlder := oatthUnix < historyUnix || (oatthUnix == historyUnix && oatth.ID < history.ID)
	historyOlder := oatthUnix > historyUnix || (oatthUnix == historyUnix && oatth.ID > history.ID)

	if oatthOlder {
		return &HistoryDiff[OhAuthTooTokenHistory]{
			Old:     oatth,
			New:     history,
			Changes: oatth.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OhAuthTooTokenHistory]{
			Old:     history,
			New:     oatth,
			Changes: history.changes(oatth),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (oh *OrganizationHistory) changes(new *OrganizationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(oh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldCreatedAt, oh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(oh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldUpdatedAt, oh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(oh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(organizationhistory.FieldCreatedBy, oh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(oh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldDeletedAt, oh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(oh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(organizationhistory.FieldDeletedBy, oh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(oh.Name, new.Name) {
		changes = append(changes, NewChange(organizationhistory.FieldName, oh.Name, new.Name))
	}
	if !reflect.DeepEqual(oh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(organizationhistory.FieldDisplayName, oh.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(oh.Description, new.Description) {
		changes = append(changes, NewChange(organizationhistory.FieldDescription, oh.Description, new.Description))
	}
	if !reflect.DeepEqual(oh.ParentOrganizationID, new.ParentOrganizationID) {
		changes = append(changes, NewChange(organizationhistory.FieldParentOrganizationID, oh.ParentOrganizationID, new.ParentOrganizationID))
	}
	if !reflect.DeepEqual(oh.PersonalOrg, new.PersonalOrg) {
		changes = append(changes, NewChange(organizationhistory.FieldPersonalOrg, oh.PersonalOrg, new.PersonalOrg))
	}
	return changes
}

func (oh *OrganizationHistory) Diff(history *OrganizationHistory) (*HistoryDiff[OrganizationHistory], error) {
	if oh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ohUnix, historyUnix := oh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ohOlder := ohUnix < historyUnix || (ohUnix == historyUnix && oh.ID < history.ID)
	historyOlder := ohUnix > historyUnix || (ohUnix == historyUnix && oh.ID > history.ID)

	if ohOlder {
		return &HistoryDiff[OrganizationHistory]{
			Old:     oh,
			New:     history,
			Changes: oh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrganizationHistory]{
			Old:     history,
			New:     oh,
			Changes: history.changes(oh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (osh *OrganizationSettingHistory) changes(new *OrganizationSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(osh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldCreatedAt, osh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(osh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldUpdatedAt, osh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(osh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldCreatedBy, osh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(osh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDeletedAt, osh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(osh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDeletedBy, osh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(osh.Domains, new.Domains) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDomains, osh.Domains, new.Domains))
	}
	if !reflect.DeepEqual(osh.SSOCert, new.SSOCert) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldSSOCert, osh.SSOCert, new.SSOCert))
	}
	if !reflect.DeepEqual(osh.SSOEntrypoint, new.SSOEntrypoint) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldSSOEntrypoint, osh.SSOEntrypoint, new.SSOEntrypoint))
	}
	if !reflect.DeepEqual(osh.SSOIssuer, new.SSOIssuer) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldSSOIssuer, osh.SSOIssuer, new.SSOIssuer))
	}
	if !reflect.DeepEqual(osh.BillingContact, new.BillingContact) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingContact, osh.BillingContact, new.BillingContact))
	}
	if !reflect.DeepEqual(osh.BillingEmail, new.BillingEmail) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingEmail, osh.BillingEmail, new.BillingEmail))
	}
	if !reflect.DeepEqual(osh.BillingPhone, new.BillingPhone) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingPhone, osh.BillingPhone, new.BillingPhone))
	}
	if !reflect.DeepEqual(osh.BillingAddress, new.BillingAddress) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingAddress, osh.BillingAddress, new.BillingAddress))
	}
	if !reflect.DeepEqual(osh.TaxIdentifier, new.TaxIdentifier) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldTaxIdentifier, osh.TaxIdentifier, new.TaxIdentifier))
	}
	if !reflect.DeepEqual(osh.Tags, new.Tags) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldTags, osh.Tags, new.Tags))
	}
	return changes
}

func (osh *OrganizationSettingHistory) Diff(history *OrganizationSettingHistory) (*HistoryDiff[OrganizationSettingHistory], error) {
	if osh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	oshUnix, historyUnix := osh.HistoryTime.Unix(), history.HistoryTime.Unix()
	oshOlder := oshUnix < historyUnix || (oshUnix == historyUnix && osh.ID < history.ID)
	historyOlder := oshUnix > historyUnix || (oshUnix == historyUnix && osh.ID > history.ID)

	if oshOlder {
		return &HistoryDiff[OrganizationSettingHistory]{
			Old:     osh,
			New:     history,
			Changes: osh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrganizationSettingHistory]{
			Old:     history,
			New:     osh,
			Changes: history.changes(osh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (prth *PasswordResetTokenHistory) changes(new *PasswordResetTokenHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(prth.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldCreatedAt, prth.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(prth.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldUpdatedAt, prth.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(prth.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldCreatedBy, prth.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(prth.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldDeletedAt, prth.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(prth.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldDeletedBy, prth.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(prth.Token, new.Token) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldToken, prth.Token, new.Token))
	}
	if !reflect.DeepEqual(prth.TTL, new.TTL) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldTTL, prth.TTL, new.TTL))
	}
	if !reflect.DeepEqual(prth.Email, new.Email) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldEmail, prth.Email, new.Email))
	}
	if !reflect.DeepEqual(prth.Secret, new.Secret) {
		changes = append(changes, NewChange(passwordresettokenhistory.FieldSecret, prth.Secret, new.Secret))
	}
	return changes
}

func (prth *PasswordResetTokenHistory) Diff(history *PasswordResetTokenHistory) (*HistoryDiff[PasswordResetTokenHistory], error) {
	if prth.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	prthUnix, historyUnix := prth.HistoryTime.Unix(), history.HistoryTime.Unix()
	prthOlder := prthUnix < historyUnix || (prthUnix == historyUnix && prth.ID < history.ID)
	historyOlder := prthUnix > historyUnix || (prthUnix == historyUnix && prth.ID > history.ID)

	if prthOlder {
		return &HistoryDiff[PasswordResetTokenHistory]{
			Old:     prth,
			New:     history,
			Changes: prth.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[PasswordResetTokenHistory]{
			Old:     history,
			New:     prth,
			Changes: history.changes(prth),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (path *PersonalAccessTokenHistory) changes(new *PersonalAccessTokenHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(path.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldCreatedAt, path.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(path.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldUpdatedAt, path.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(path.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldCreatedBy, path.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(path.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldDeletedAt, path.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(path.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldDeletedBy, path.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(path.Name, new.Name) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldName, path.Name, new.Name))
	}
	if !reflect.DeepEqual(path.Token, new.Token) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldToken, path.Token, new.Token))
	}
	if !reflect.DeepEqual(path.Abilities, new.Abilities) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldAbilities, path.Abilities, new.Abilities))
	}
	if !reflect.DeepEqual(path.ExpiresAt, new.ExpiresAt) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldExpiresAt, path.ExpiresAt, new.ExpiresAt))
	}
	if !reflect.DeepEqual(path.Description, new.Description) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldDescription, path.Description, new.Description))
	}
	if !reflect.DeepEqual(path.LastUsedAt, new.LastUsedAt) {
		changes = append(changes, NewChange(personalaccesstokenhistory.FieldLastUsedAt, path.LastUsedAt, new.LastUsedAt))
	}
	return changes
}

func (path *PersonalAccessTokenHistory) Diff(history *PersonalAccessTokenHistory) (*HistoryDiff[PersonalAccessTokenHistory], error) {
	if path.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	pathUnix, historyUnix := path.HistoryTime.Unix(), history.HistoryTime.Unix()
	pathOlder := pathUnix < historyUnix || (pathUnix == historyUnix && path.ID < history.ID)
	historyOlder := pathUnix > historyUnix || (pathUnix == historyUnix && path.ID > history.ID)

	if pathOlder {
		return &HistoryDiff[PersonalAccessTokenHistory]{
			Old:     path,
			New:     history,
			Changes: path.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[PersonalAccessTokenHistory]{
			Old:     history,
			New:     path,
			Changes: history.changes(path),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (sh *SessionHistory) changes(new *SessionHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(sh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(sessionhistory.FieldCreatedAt, sh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(sh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(sessionhistory.FieldUpdatedAt, sh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(sh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(sessionhistory.FieldCreatedBy, sh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(sh.SessionToken, new.SessionToken) {
		changes = append(changes, NewChange(sessionhistory.FieldSessionToken, sh.SessionToken, new.SessionToken))
	}
	if !reflect.DeepEqual(sh.IssuedAt, new.IssuedAt) {
		changes = append(changes, NewChange(sessionhistory.FieldIssuedAt, sh.IssuedAt, new.IssuedAt))
	}
	if !reflect.DeepEqual(sh.ExpiresAt, new.ExpiresAt) {
		changes = append(changes, NewChange(sessionhistory.FieldExpiresAt, sh.ExpiresAt, new.ExpiresAt))
	}
	if !reflect.DeepEqual(sh.OrganizationID, new.OrganizationID) {
		changes = append(changes, NewChange(sessionhistory.FieldOrganizationID, sh.OrganizationID, new.OrganizationID))
	}
	if !reflect.DeepEqual(sh.UserID, new.UserID) {
		changes = append(changes, NewChange(sessionhistory.FieldUserID, sh.UserID, new.UserID))
	}
	return changes
}

func (sh *SessionHistory) Diff(history *SessionHistory) (*HistoryDiff[SessionHistory], error) {
	if sh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	shUnix, historyUnix := sh.HistoryTime.Unix(), history.HistoryTime.Unix()
	shOlder := shUnix < historyUnix || (shUnix == historyUnix && sh.ID < history.ID)
	historyOlder := shUnix > historyUnix || (shUnix == historyUnix && sh.ID > history.ID)

	if shOlder {
		return &HistoryDiff[SessionHistory]{
			Old:     sh,
			New:     history,
			Changes: sh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[SessionHistory]{
			Old:     history,
			New:     sh,
			Changes: history.changes(sh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (uh *UserHistory) changes(new *UserHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(uh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(userhistory.FieldCreatedAt, uh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(uh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(userhistory.FieldUpdatedAt, uh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(uh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(userhistory.FieldCreatedBy, uh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(uh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(userhistory.FieldDeletedAt, uh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(uh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(userhistory.FieldDeletedBy, uh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(uh.Email, new.Email) {
		changes = append(changes, NewChange(userhistory.FieldEmail, uh.Email, new.Email))
	}
	if !reflect.DeepEqual(uh.FirstName, new.FirstName) {
		changes = append(changes, NewChange(userhistory.FieldFirstName, uh.FirstName, new.FirstName))
	}
	if !reflect.DeepEqual(uh.LastName, new.LastName) {
		changes = append(changes, NewChange(userhistory.FieldLastName, uh.LastName, new.LastName))
	}
	if !reflect.DeepEqual(uh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(userhistory.FieldDisplayName, uh.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(uh.AvatarRemoteURL, new.AvatarRemoteURL) {
		changes = append(changes, NewChange(userhistory.FieldAvatarRemoteURL, uh.AvatarRemoteURL, new.AvatarRemoteURL))
	}
	if !reflect.DeepEqual(uh.AvatarLocalFile, new.AvatarLocalFile) {
		changes = append(changes, NewChange(userhistory.FieldAvatarLocalFile, uh.AvatarLocalFile, new.AvatarLocalFile))
	}
	if !reflect.DeepEqual(uh.AvatarUpdatedAt, new.AvatarUpdatedAt) {
		changes = append(changes, NewChange(userhistory.FieldAvatarUpdatedAt, uh.AvatarUpdatedAt, new.AvatarUpdatedAt))
	}
	if !reflect.DeepEqual(uh.LastSeen, new.LastSeen) {
		changes = append(changes, NewChange(userhistory.FieldLastSeen, uh.LastSeen, new.LastSeen))
	}
	if !reflect.DeepEqual(uh.Password, new.Password) {
		changes = append(changes, NewChange(userhistory.FieldPassword, uh.Password, new.Password))
	}
	if !reflect.DeepEqual(uh.Sub, new.Sub) {
		changes = append(changes, NewChange(userhistory.FieldSub, uh.Sub, new.Sub))
	}
	if !reflect.DeepEqual(uh.Oauth, new.Oauth) {
		changes = append(changes, NewChange(userhistory.FieldOauth, uh.Oauth, new.Oauth))
	}
	return changes
}

func (uh *UserHistory) Diff(history *UserHistory) (*HistoryDiff[UserHistory], error) {
	if uh.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	uhUnix, historyUnix := uh.HistoryTime.Unix(), history.HistoryTime.Unix()
	uhOlder := uhUnix < historyUnix || (uhUnix == historyUnix && uh.ID < history.ID)
	historyOlder := uhUnix > historyUnix || (uhUnix == historyUnix && uh.ID > history.ID)

	if uhOlder {
		return &HistoryDiff[UserHistory]{
			Old:     uh,
			New:     history,
			Changes: uh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[UserHistory]{
			Old:     history,
			New:     uh,
			Changes: history.changes(uh),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (ush *UserSettingHistory) changes(new *UserSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ush.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldCreatedAt, ush.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ush.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldUpdatedAt, ush.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ush.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(usersettinghistory.FieldCreatedBy, ush.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ush.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldDeletedAt, ush.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ush.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(usersettinghistory.FieldDeletedBy, ush.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ush.Locked, new.Locked) {
		changes = append(changes, NewChange(usersettinghistory.FieldLocked, ush.Locked, new.Locked))
	}
	if !reflect.DeepEqual(ush.SilencedAt, new.SilencedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldSilencedAt, ush.SilencedAt, new.SilencedAt))
	}
	if !reflect.DeepEqual(ush.SuspendedAt, new.SuspendedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldSuspendedAt, ush.SuspendedAt, new.SuspendedAt))
	}
	if !reflect.DeepEqual(ush.RecoveryCode, new.RecoveryCode) {
		changes = append(changes, NewChange(usersettinghistory.FieldRecoveryCode, ush.RecoveryCode, new.RecoveryCode))
	}
	if !reflect.DeepEqual(ush.Status, new.Status) {
		changes = append(changes, NewChange(usersettinghistory.FieldStatus, ush.Status, new.Status))
	}
	if !reflect.DeepEqual(ush.Role, new.Role) {
		changes = append(changes, NewChange(usersettinghistory.FieldRole, ush.Role, new.Role))
	}
	if !reflect.DeepEqual(ush.Permissions, new.Permissions) {
		changes = append(changes, NewChange(usersettinghistory.FieldPermissions, ush.Permissions, new.Permissions))
	}
	if !reflect.DeepEqual(ush.EmailConfirmed, new.EmailConfirmed) {
		changes = append(changes, NewChange(usersettinghistory.FieldEmailConfirmed, ush.EmailConfirmed, new.EmailConfirmed))
	}
	if !reflect.DeepEqual(ush.Tags, new.Tags) {
		changes = append(changes, NewChange(usersettinghistory.FieldTags, ush.Tags, new.Tags))
	}
	return changes
}

func (ush *UserSettingHistory) Diff(history *UserSettingHistory) (*HistoryDiff[UserSettingHistory], error) {
	if ush.Ref != history.Ref {
		return nil, MismatchedRefError
	}

	ushUnix, historyUnix := ush.HistoryTime.Unix(), history.HistoryTime.Unix()
	ushOlder := ushUnix < historyUnix || (ushUnix == historyUnix && ush.ID < history.ID)
	historyOlder := ushUnix > historyUnix || (ushUnix == historyUnix && ush.ID > history.ID)

	if ushOlder {
		return &HistoryDiff[UserSettingHistory]{
			Old:     ush,
			New:     history,
			Changes: ush.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[UserSettingHistory]{
			Old:     history,
			New:     ush,
			Changes: history.changes(ush),
		}, nil
	}
	return nil, IdenticalHistoryError
}

func (c Change) String(op enthistory.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%#v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%#v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case enthistory.OpTypeInsert:
		return fmt.Sprintf("%s: %#s", c.FieldName, newstr)
	case enthistory.OpTypeDelete:
		return fmt.Sprintf("%s: %#s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %#s -> %#s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context) ([][]string, error) {
	records := [][]string{
		{"Table", "Ref Id", "History Time", "Operation", "Changes"},
	}
	var record [][]string
	var err error
	record, err = auditEmailVerificationTokenHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditEntitlementHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditGroupHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditGroupSettingHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditIntegrationHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditOauthProviderHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditOhAuthTooTokenHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditOrganizationHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditOrganizationSettingHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditPasswordResetTokenHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditPersonalAccessTokenHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditSessionHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditUserHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	record, err = auditUserSettingHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, record...)

	return records, nil
}

type record struct {
	Table       string
	RefId       any
	HistoryTime time.Time
	Operation   enthistory.OpType
	Changes     []Change
}

func (r *record) toRow() []string {
	row := make([]string, 5)

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefId)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	return row
}

type emailverificationtokenhistoryref struct {
	Ref string
}

func auditEmailVerificationTokenHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []emailverificationtokenhistoryref
	client := NewEmailVerificationTokenHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(emailverificationtokenhistory.ByRef()).
		Select(emailverificationtokenhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(emailverificationtokenhistory.Ref(currRef.Ref)).
			Order(emailverificationtokenhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "EmailVerificationTokenHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&EmailVerificationTokenHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&EmailVerificationTokenHistory{})
			default:
				if i == 0 {
					record.Changes = (&EmailVerificationTokenHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type entitlementhistoryref struct {
	Ref string
}

func auditEntitlementHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []entitlementhistoryref
	client := NewEntitlementHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(entitlementhistory.ByRef()).
		Select(entitlementhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(entitlementhistory.Ref(currRef.Ref)).
			Order(entitlementhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "EntitlementHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&EntitlementHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&EntitlementHistory{})
			default:
				if i == 0 {
					record.Changes = (&EntitlementHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type grouphistoryref struct {
	Ref string
}

func auditGroupHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []grouphistoryref
	client := NewGroupHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(grouphistory.ByRef()).
		Select(grouphistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(grouphistory.Ref(currRef.Ref)).
			Order(grouphistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "GroupHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&GroupHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&GroupHistory{})
			default:
				if i == 0 {
					record.Changes = (&GroupHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type groupsettinghistoryref struct {
	Ref string
}

func auditGroupSettingHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []groupsettinghistoryref
	client := NewGroupSettingHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(groupsettinghistory.ByRef()).
		Select(groupsettinghistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(groupsettinghistory.Ref(currRef.Ref)).
			Order(groupsettinghistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "GroupSettingHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&GroupSettingHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&GroupSettingHistory{})
			default:
				if i == 0 {
					record.Changes = (&GroupSettingHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type integrationhistoryref struct {
	Ref string
}

func auditIntegrationHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []integrationhistoryref
	client := NewIntegrationHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(integrationhistory.ByRef()).
		Select(integrationhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(integrationhistory.Ref(currRef.Ref)).
			Order(integrationhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "IntegrationHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&IntegrationHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&IntegrationHistory{})
			default:
				if i == 0 {
					record.Changes = (&IntegrationHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type oauthproviderhistoryref struct {
	Ref string
}

func auditOauthProviderHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []oauthproviderhistoryref
	client := NewOauthProviderHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(oauthproviderhistory.ByRef()).
		Select(oauthproviderhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(oauthproviderhistory.Ref(currRef.Ref)).
			Order(oauthproviderhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "OauthProviderHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&OauthProviderHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&OauthProviderHistory{})
			default:
				if i == 0 {
					record.Changes = (&OauthProviderHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type ohauthtootokenhistoryref struct {
	Ref string
}

func auditOhAuthTooTokenHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []ohauthtootokenhistoryref
	client := NewOhAuthTooTokenHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(ohauthtootokenhistory.ByRef()).
		Select(ohauthtootokenhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(ohauthtootokenhistory.Ref(currRef.Ref)).
			Order(ohauthtootokenhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "OhAuthTooTokenHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&OhAuthTooTokenHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&OhAuthTooTokenHistory{})
			default:
				if i == 0 {
					record.Changes = (&OhAuthTooTokenHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type organizationhistoryref struct {
	Ref string
}

func auditOrganizationHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []organizationhistoryref
	client := NewOrganizationHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(organizationhistory.ByRef()).
		Select(organizationhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(organizationhistory.Ref(currRef.Ref)).
			Order(organizationhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "OrganizationHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&OrganizationHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&OrganizationHistory{})
			default:
				if i == 0 {
					record.Changes = (&OrganizationHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type organizationsettinghistoryref struct {
	Ref string
}

func auditOrganizationSettingHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []organizationsettinghistoryref
	client := NewOrganizationSettingHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(organizationsettinghistory.ByRef()).
		Select(organizationsettinghistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(organizationsettinghistory.Ref(currRef.Ref)).
			Order(organizationsettinghistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "OrganizationSettingHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&OrganizationSettingHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&OrganizationSettingHistory{})
			default:
				if i == 0 {
					record.Changes = (&OrganizationSettingHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type passwordresettokenhistoryref struct {
	Ref string
}

func auditPasswordResetTokenHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []passwordresettokenhistoryref
	client := NewPasswordResetTokenHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(passwordresettokenhistory.ByRef()).
		Select(passwordresettokenhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(passwordresettokenhistory.Ref(currRef.Ref)).
			Order(passwordresettokenhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "PasswordResetTokenHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&PasswordResetTokenHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&PasswordResetTokenHistory{})
			default:
				if i == 0 {
					record.Changes = (&PasswordResetTokenHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type personalaccesstokenhistoryref struct {
	Ref string
}

func auditPersonalAccessTokenHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []personalaccesstokenhistoryref
	client := NewPersonalAccessTokenHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(personalaccesstokenhistory.ByRef()).
		Select(personalaccesstokenhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(personalaccesstokenhistory.Ref(currRef.Ref)).
			Order(personalaccesstokenhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "PersonalAccessTokenHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&PersonalAccessTokenHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&PersonalAccessTokenHistory{})
			default:
				if i == 0 {
					record.Changes = (&PersonalAccessTokenHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type sessionhistoryref struct {
	Ref string
}

func auditSessionHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []sessionhistoryref
	client := NewSessionHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(sessionhistory.ByRef()).
		Select(sessionhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(sessionhistory.Ref(currRef.Ref)).
			Order(sessionhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "SessionHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&SessionHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&SessionHistory{})
			default:
				if i == 0 {
					record.Changes = (&SessionHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type userhistoryref struct {
	Ref string
}

func auditUserHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []userhistoryref
	client := NewUserHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(userhistory.ByRef()).
		Select(userhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(userhistory.Ref(currRef.Ref)).
			Order(userhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "UserHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&UserHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&UserHistory{})
			default:
				if i == 0 {
					record.Changes = (&UserHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

type usersettinghistoryref struct {
	Ref string
}

func auditUserSettingHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []usersettinghistoryref
	client := NewUserSettingHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(usersettinghistory.ByRef()).
		Select(usersettinghistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(usersettinghistory.Ref(currRef.Ref)).
			Order(usersettinghistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "UserSettingHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&UserSettingHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&UserSettingHistory{})
			default:
				if i == 0 {
					record.Changes = (&UserSettingHistory{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}
