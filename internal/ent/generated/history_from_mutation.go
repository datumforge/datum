// Code generated by enthistory, DO NOT EDIT.

// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent"
	"github.com/flume/enthistory"
)

var (
	idNotFoundError = errors.New("could not get id from mutation")
)

func EntOpToHistoryOp(op ent.Op) enthistory.OpType {
	switch op {
	case ent.OpDelete, ent.OpDeleteOne:
		return enthistory.OpTypeDelete
	case ent.OpUpdate, ent.OpUpdateOne:
		return enthistory.OpTypeUpdate
	default:
		return enthistory.OpTypeInsert
	}
}

func rollback(tx *Tx, err error) error {
	if tx != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
		}
		return err
	}
	return err
}

func (m *EmailVerificationTokenMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.EmailVerificationTokenHistory.Create()
	if tx != nil {
		create = tx.EmailVerificationTokenHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if token, exists := m.Token(); exists {
		create = create.SetToken(token)
	}

	if ttl, exists := m.TTL(); exists {
		create = create.SetNillableTTL(&ttl)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if secret, exists := m.Secret(); exists {
		create = create.SetNillableSecret(&secret)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *EmailVerificationTokenMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		emailverificationtoken, err := client.EmailVerificationToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.EmailVerificationTokenHistory.Create()
		if tx != nil {
			create = tx.EmailVerificationTokenHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(emailverificationtoken.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(emailverificationtoken.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(emailverificationtoken.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(emailverificationtoken.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(emailverificationtoken.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(emailverificationtoken.DeletedBy)
		}

		if token, exists := m.Token(); exists {
			create = create.SetToken(token)
		} else {
			create = create.SetToken(emailverificationtoken.Token)
		}

		if ttl, exists := m.TTL(); exists {
			create = create.SetNillableTTL(&ttl)
		} else {
			create = create.SetNillableTTL(emailverificationtoken.TTL)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(emailverificationtoken.Email)
		}

		if secret, exists := m.Secret(); exists {
			create = create.SetNillableSecret(&secret)
		} else {
			create = create.SetNillableSecret(emailverificationtoken.Secret)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *EmailVerificationTokenMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		emailverificationtoken, err := client.EmailVerificationToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.EmailVerificationTokenHistory.Create()
		if tx != nil {
			create = tx.EmailVerificationTokenHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(emailverificationtoken.CreatedAt).
			SetUpdatedAt(emailverificationtoken.UpdatedAt).
			SetCreatedBy(emailverificationtoken.CreatedBy).
			SetUpdatedBy(emailverificationtoken.UpdatedBy).
			SetDeletedAt(emailverificationtoken.DeletedAt).
			SetDeletedBy(emailverificationtoken.DeletedBy).
			SetToken(emailverificationtoken.Token).
			SetNillableTTL(emailverificationtoken.TTL).
			SetEmail(emailverificationtoken.Email).
			SetNillableSecret(emailverificationtoken.Secret).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *EntitlementMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.EntitlementHistory.Create()
	if tx != nil {
		create = tx.EntitlementHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tier, exists := m.Tier(); exists {
		create = create.SetTier(tier)
	}

	if externalCustomerID, exists := m.ExternalCustomerID(); exists {
		create = create.SetExternalCustomerID(externalCustomerID)
	}

	if externalSubscriptionID, exists := m.ExternalSubscriptionID(); exists {
		create = create.SetExternalSubscriptionID(externalSubscriptionID)
	}

	if expires, exists := m.Expires(); exists {
		create = create.SetExpires(expires)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetNillableExpiresAt(&expiresAt)
	}

	if cancelled, exists := m.Cancelled(); exists {
		create = create.SetCancelled(cancelled)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *EntitlementMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		entitlement, err := client.Entitlement.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.EntitlementHistory.Create()
		if tx != nil {
			create = tx.EntitlementHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitlement.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitlement.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entitlement.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entitlement.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(entitlement.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(entitlement.DeletedBy)
		}

		if tier, exists := m.Tier(); exists {
			create = create.SetTier(tier)
		} else {
			create = create.SetTier(entitlement.Tier)
		}

		if externalCustomerID, exists := m.ExternalCustomerID(); exists {
			create = create.SetExternalCustomerID(externalCustomerID)
		} else {
			create = create.SetExternalCustomerID(entitlement.ExternalCustomerID)
		}

		if externalSubscriptionID, exists := m.ExternalSubscriptionID(); exists {
			create = create.SetExternalSubscriptionID(externalSubscriptionID)
		} else {
			create = create.SetExternalSubscriptionID(entitlement.ExternalSubscriptionID)
		}

		if expires, exists := m.Expires(); exists {
			create = create.SetExpires(expires)
		} else {
			create = create.SetExpires(entitlement.Expires)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetNillableExpiresAt(&expiresAt)
		} else {
			create = create.SetNillableExpiresAt(entitlement.ExpiresAt)
		}

		if cancelled, exists := m.Cancelled(); exists {
			create = create.SetCancelled(cancelled)
		} else {
			create = create.SetCancelled(entitlement.Cancelled)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *EntitlementMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		entitlement, err := client.Entitlement.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.EntitlementHistory.Create()
		if tx != nil {
			create = tx.EntitlementHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitlement.CreatedAt).
			SetUpdatedAt(entitlement.UpdatedAt).
			SetCreatedBy(entitlement.CreatedBy).
			SetUpdatedBy(entitlement.UpdatedBy).
			SetDeletedAt(entitlement.DeletedAt).
			SetDeletedBy(entitlement.DeletedBy).
			SetTier(entitlement.Tier).
			SetExternalCustomerID(entitlement.ExternalCustomerID).
			SetExternalSubscriptionID(entitlement.ExternalSubscriptionID).
			SetExpires(entitlement.Expires).
			SetNillableExpiresAt(entitlement.ExpiresAt).
			SetCancelled(entitlement.Cancelled).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.GroupHistory.Create()
	if tx != nil {
		create = tx.GroupHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
		create = create.SetGravatarLogoURL(gravatarLogoURL)
	}

	if logoURL, exists := m.LogoURL(); exists {
		create = create.SetLogoURL(logoURL)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *GroupMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.GroupHistory.Create()
		if tx != nil {
			create = tx.GroupHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(group.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(group.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(group.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(group.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(group.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(group.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(group.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(group.Description)
		}

		if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
			create = create.SetGravatarLogoURL(gravatarLogoURL)
		} else {
			create = create.SetGravatarLogoURL(group.GravatarLogoURL)
		}

		if logoURL, exists := m.LogoURL(); exists {
			create = create.SetLogoURL(logoURL)
		} else {
			create = create.SetLogoURL(group.LogoURL)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(group.DisplayName)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.GroupHistory.Create()
		if tx != nil {
			create = tx.GroupHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(group.CreatedAt).
			SetUpdatedAt(group.UpdatedAt).
			SetCreatedBy(group.CreatedBy).
			SetUpdatedBy(group.UpdatedBy).
			SetDeletedAt(group.DeletedAt).
			SetDeletedBy(group.DeletedBy).
			SetName(group.Name).
			SetDescription(group.Description).
			SetGravatarLogoURL(group.GravatarLogoURL).
			SetLogoURL(group.LogoURL).
			SetDisplayName(group.DisplayName).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.GroupSettingHistory.Create()
	if tx != nil {
		create = tx.GroupSettingHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if visibility, exists := m.Visibility(); exists {
		create = create.SetVisibility(visibility)
	}

	if joinPolicy, exists := m.JoinPolicy(); exists {
		create = create.SetJoinPolicy(joinPolicy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if syncToSlack, exists := m.SyncToSlack(); exists {
		create = create.SetSyncToSlack(syncToSlack)
	}

	if syncToGithub, exists := m.SyncToGithub(); exists {
		create = create.SetSyncToGithub(syncToGithub)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.GroupSettingHistory.Create()
		if tx != nil {
			create = tx.GroupSettingHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupsetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(groupsetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(groupsetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(groupsetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(groupsetting.DeletedBy)
		}

		if visibility, exists := m.Visibility(); exists {
			create = create.SetVisibility(visibility)
		} else {
			create = create.SetVisibility(groupsetting.Visibility)
		}

		if joinPolicy, exists := m.JoinPolicy(); exists {
			create = create.SetJoinPolicy(joinPolicy)
		} else {
			create = create.SetJoinPolicy(groupsetting.JoinPolicy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(groupsetting.Tags)
		}

		if syncToSlack, exists := m.SyncToSlack(); exists {
			create = create.SetSyncToSlack(syncToSlack)
		} else {
			create = create.SetSyncToSlack(groupsetting.SyncToSlack)
		}

		if syncToGithub, exists := m.SyncToGithub(); exists {
			create = create.SetSyncToGithub(syncToGithub)
		} else {
			create = create.SetSyncToGithub(groupsetting.SyncToGithub)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.GroupSettingHistory.Create()
		if tx != nil {
			create = tx.GroupSettingHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupsetting.CreatedAt).
			SetUpdatedAt(groupsetting.UpdatedAt).
			SetCreatedBy(groupsetting.CreatedBy).
			SetUpdatedBy(groupsetting.UpdatedBy).
			SetDeletedAt(groupsetting.DeletedAt).
			SetDeletedBy(groupsetting.DeletedBy).
			SetVisibility(groupsetting.Visibility).
			SetJoinPolicy(groupsetting.JoinPolicy).
			SetTags(groupsetting.Tags).
			SetSyncToSlack(groupsetting.SyncToSlack).
			SetSyncToGithub(groupsetting.SyncToGithub).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.IntegrationHistory.Create()
	if tx != nil {
		create = tx.IntegrationHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if secretName, exists := m.SecretName(); exists {
		create = create.SetSecretName(secretName)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *IntegrationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.IntegrationHistory.Create()
		if tx != nil {
			create = tx.IntegrationHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(integration.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(integration.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(integration.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(integration.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(integration.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(integration.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(integration.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(integration.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(integration.Kind)
		}

		if secretName, exists := m.SecretName(); exists {
			create = create.SetSecretName(secretName)
		} else {
			create = create.SetSecretName(integration.SecretName)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.IntegrationHistory.Create()
		if tx != nil {
			create = tx.IntegrationHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(integration.CreatedAt).
			SetUpdatedAt(integration.UpdatedAt).
			SetCreatedBy(integration.CreatedBy).
			SetUpdatedBy(integration.UpdatedBy).
			SetDeletedAt(integration.DeletedAt).
			SetDeletedBy(integration.DeletedBy).
			SetName(integration.Name).
			SetDescription(integration.Description).
			SetKind(integration.Kind).
			SetSecretName(integration.SecretName).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OauthProviderMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.OauthProviderHistory.Create()
	if tx != nil {
		create = tx.OauthProviderHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if clientID, exists := m.ClientID(); exists {
		create = create.SetClientID(clientID)
	}

	if clientSecret, exists := m.ClientSecret(); exists {
		create = create.SetClientSecret(clientSecret)
	}

	if redirectURL, exists := m.RedirectURL(); exists {
		create = create.SetRedirectURL(redirectURL)
	}

	if scopes, exists := m.Scopes(); exists {
		create = create.SetScopes(scopes)
	}

	if authURL, exists := m.AuthURL(); exists {
		create = create.SetAuthURL(authURL)
	}

	if tokenURL, exists := m.TokenURL(); exists {
		create = create.SetTokenURL(tokenURL)
	}

	if authStyle, exists := m.AuthStyle(); exists {
		create = create.SetAuthStyle(authStyle)
	}

	if infoURL, exists := m.InfoURL(); exists {
		create = create.SetInfoURL(infoURL)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *OauthProviderMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		oauthprovider, err := client.OauthProvider.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OauthProviderHistory.Create()
		if tx != nil {
			create = tx.OauthProviderHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(oauthprovider.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(oauthprovider.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(oauthprovider.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(oauthprovider.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(oauthprovider.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(oauthprovider.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(oauthprovider.Name)
		}

		if clientID, exists := m.ClientID(); exists {
			create = create.SetClientID(clientID)
		} else {
			create = create.SetClientID(oauthprovider.ClientID)
		}

		if clientSecret, exists := m.ClientSecret(); exists {
			create = create.SetClientSecret(clientSecret)
		} else {
			create = create.SetClientSecret(oauthprovider.ClientSecret)
		}

		if redirectURL, exists := m.RedirectURL(); exists {
			create = create.SetRedirectURL(redirectURL)
		} else {
			create = create.SetRedirectURL(oauthprovider.RedirectURL)
		}

		if scopes, exists := m.Scopes(); exists {
			create = create.SetScopes(scopes)
		} else {
			create = create.SetScopes(oauthprovider.Scopes)
		}

		if authURL, exists := m.AuthURL(); exists {
			create = create.SetAuthURL(authURL)
		} else {
			create = create.SetAuthURL(oauthprovider.AuthURL)
		}

		if tokenURL, exists := m.TokenURL(); exists {
			create = create.SetTokenURL(tokenURL)
		} else {
			create = create.SetTokenURL(oauthprovider.TokenURL)
		}

		if authStyle, exists := m.AuthStyle(); exists {
			create = create.SetAuthStyle(authStyle)
		} else {
			create = create.SetAuthStyle(oauthprovider.AuthStyle)
		}

		if infoURL, exists := m.InfoURL(); exists {
			create = create.SetInfoURL(infoURL)
		} else {
			create = create.SetInfoURL(oauthprovider.InfoURL)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OauthProviderMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		oauthprovider, err := client.OauthProvider.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OauthProviderHistory.Create()
		if tx != nil {
			create = tx.OauthProviderHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(oauthprovider.CreatedAt).
			SetUpdatedAt(oauthprovider.UpdatedAt).
			SetCreatedBy(oauthprovider.CreatedBy).
			SetUpdatedBy(oauthprovider.UpdatedBy).
			SetDeletedAt(oauthprovider.DeletedAt).
			SetDeletedBy(oauthprovider.DeletedBy).
			SetName(oauthprovider.Name).
			SetClientID(oauthprovider.ClientID).
			SetClientSecret(oauthprovider.ClientSecret).
			SetRedirectURL(oauthprovider.RedirectURL).
			SetScopes(oauthprovider.Scopes).
			SetAuthURL(oauthprovider.AuthURL).
			SetTokenURL(oauthprovider.TokenURL).
			SetAuthStyle(oauthprovider.AuthStyle).
			SetInfoURL(oauthprovider.InfoURL).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OhAuthTooTokenMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.OhAuthTooTokenHistory.Create()
	if tx != nil {
		create = tx.OhAuthTooTokenHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if clientID, exists := m.ClientID(); exists {
		create = create.SetClientID(clientID)
	}

	if scopes, exists := m.Scopes(); exists {
		create = create.SetScopes(scopes)
	}

	if nonce, exists := m.Nonce(); exists {
		create = create.SetNonce(nonce)
	}

	if claimsUserID, exists := m.ClaimsUserID(); exists {
		create = create.SetClaimsUserID(claimsUserID)
	}

	if claimsUsername, exists := m.ClaimsUsername(); exists {
		create = create.SetClaimsUsername(claimsUsername)
	}

	if claimsEmail, exists := m.ClaimsEmail(); exists {
		create = create.SetClaimsEmail(claimsEmail)
	}

	if claimsEmailVerified, exists := m.ClaimsEmailVerified(); exists {
		create = create.SetClaimsEmailVerified(claimsEmailVerified)
	}

	if claimsGroups, exists := m.ClaimsGroups(); exists {
		create = create.SetClaimsGroups(claimsGroups)
	}

	if claimsPreferredUsername, exists := m.ClaimsPreferredUsername(); exists {
		create = create.SetClaimsPreferredUsername(claimsPreferredUsername)
	}

	if connectorID, exists := m.ConnectorID(); exists {
		create = create.SetConnectorID(connectorID)
	}

	if connectorData, exists := m.ConnectorData(); exists {
		create = create.SetConnectorData(connectorData)
	}

	if lastUsed, exists := m.LastUsed(); exists {
		create = create.SetLastUsed(lastUsed)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *OhAuthTooTokenMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		ohauthtootoken, err := client.OhAuthTooToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OhAuthTooTokenHistory.Create()
		if tx != nil {
			create = tx.OhAuthTooTokenHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if clientID, exists := m.ClientID(); exists {
			create = create.SetClientID(clientID)
		} else {
			create = create.SetClientID(ohauthtootoken.ClientID)
		}

		if scopes, exists := m.Scopes(); exists {
			create = create.SetScopes(scopes)
		} else {
			create = create.SetScopes(ohauthtootoken.Scopes)
		}

		if nonce, exists := m.Nonce(); exists {
			create = create.SetNonce(nonce)
		} else {
			create = create.SetNonce(ohauthtootoken.Nonce)
		}

		if claimsUserID, exists := m.ClaimsUserID(); exists {
			create = create.SetClaimsUserID(claimsUserID)
		} else {
			create = create.SetClaimsUserID(ohauthtootoken.ClaimsUserID)
		}

		if claimsUsername, exists := m.ClaimsUsername(); exists {
			create = create.SetClaimsUsername(claimsUsername)
		} else {
			create = create.SetClaimsUsername(ohauthtootoken.ClaimsUsername)
		}

		if claimsEmail, exists := m.ClaimsEmail(); exists {
			create = create.SetClaimsEmail(claimsEmail)
		} else {
			create = create.SetClaimsEmail(ohauthtootoken.ClaimsEmail)
		}

		if claimsEmailVerified, exists := m.ClaimsEmailVerified(); exists {
			create = create.SetClaimsEmailVerified(claimsEmailVerified)
		} else {
			create = create.SetClaimsEmailVerified(ohauthtootoken.ClaimsEmailVerified)
		}

		if claimsGroups, exists := m.ClaimsGroups(); exists {
			create = create.SetClaimsGroups(claimsGroups)
		} else {
			create = create.SetClaimsGroups(ohauthtootoken.ClaimsGroups)
		}

		if claimsPreferredUsername, exists := m.ClaimsPreferredUsername(); exists {
			create = create.SetClaimsPreferredUsername(claimsPreferredUsername)
		} else {
			create = create.SetClaimsPreferredUsername(ohauthtootoken.ClaimsPreferredUsername)
		}

		if connectorID, exists := m.ConnectorID(); exists {
			create = create.SetConnectorID(connectorID)
		} else {
			create = create.SetConnectorID(ohauthtootoken.ConnectorID)
		}

		if connectorData, exists := m.ConnectorData(); exists {
			create = create.SetConnectorData(connectorData)
		} else {
			create = create.SetConnectorData(ohauthtootoken.ConnectorData)
		}

		if lastUsed, exists := m.LastUsed(); exists {
			create = create.SetLastUsed(lastUsed)
		} else {
			create = create.SetLastUsed(ohauthtootoken.LastUsed)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OhAuthTooTokenMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		ohauthtootoken, err := client.OhAuthTooToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OhAuthTooTokenHistory.Create()
		if tx != nil {
			create = tx.OhAuthTooTokenHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetClientID(ohauthtootoken.ClientID).
			SetScopes(ohauthtootoken.Scopes).
			SetNonce(ohauthtootoken.Nonce).
			SetClaimsUserID(ohauthtootoken.ClaimsUserID).
			SetClaimsUsername(ohauthtootoken.ClaimsUsername).
			SetClaimsEmail(ohauthtootoken.ClaimsEmail).
			SetClaimsEmailVerified(ohauthtootoken.ClaimsEmailVerified).
			SetClaimsGroups(ohauthtootoken.ClaimsGroups).
			SetClaimsPreferredUsername(ohauthtootoken.ClaimsPreferredUsername).
			SetConnectorID(ohauthtootoken.ConnectorID).
			SetConnectorData(ohauthtootoken.ConnectorData).
			SetLastUsed(ohauthtootoken.LastUsed).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.OrganizationHistory.Create()
	if tx != nil {
		create = tx.OrganizationHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
		create = create.SetParentOrganizationID(parentOrganizationID)
	}

	if personalOrg, exists := m.PersonalOrg(); exists {
		create = create.SetPersonalOrg(personalOrg)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *OrganizationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OrganizationHistory.Create()
		if tx != nil {
			create = tx.OrganizationHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organization.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organization.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(organization.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(organization.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(organization.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(organization.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(organization.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(organization.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(organization.Description)
		}

		if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
			create = create.SetParentOrganizationID(parentOrganizationID)
		} else {
			create = create.SetParentOrganizationID(organization.ParentOrganizationID)
		}

		if personalOrg, exists := m.PersonalOrg(); exists {
			create = create.SetPersonalOrg(personalOrg)
		} else {
			create = create.SetPersonalOrg(organization.PersonalOrg)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OrganizationHistory.Create()
		if tx != nil {
			create = tx.OrganizationHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organization.CreatedAt).
			SetUpdatedAt(organization.UpdatedAt).
			SetCreatedBy(organization.CreatedBy).
			SetUpdatedBy(organization.UpdatedBy).
			SetDeletedAt(organization.DeletedAt).
			SetDeletedBy(organization.DeletedBy).
			SetName(organization.Name).
			SetDisplayName(organization.DisplayName).
			SetDescription(organization.Description).
			SetParentOrganizationID(organization.ParentOrganizationID).
			SetPersonalOrg(organization.PersonalOrg).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.OrganizationSettingHistory.Create()
	if tx != nil {
		create = tx.OrganizationSettingHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if ssoCert, exists := m.SSOCert(); exists {
		create = create.SetSSOCert(ssoCert)
	}

	if ssoEntrypoint, exists := m.SSOEntrypoint(); exists {
		create = create.SetSSOEntrypoint(ssoEntrypoint)
	}

	if ssoIssuer, exists := m.SSOIssuer(); exists {
		create = create.SetSSOIssuer(ssoIssuer)
	}

	if billingContact, exists := m.BillingContact(); exists {
		create = create.SetBillingContact(billingContact)
	}

	if billingEmail, exists := m.BillingEmail(); exists {
		create = create.SetBillingEmail(billingEmail)
	}

	if billingPhone, exists := m.BillingPhone(); exists {
		create = create.SetBillingPhone(billingPhone)
	}

	if billingAddress, exists := m.BillingAddress(); exists {
		create = create.SetBillingAddress(billingAddress)
	}

	if taxIdentifier, exists := m.TaxIdentifier(); exists {
		create = create.SetTaxIdentifier(taxIdentifier)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OrganizationSettingHistory.Create()
		if tx != nil {
			create = tx.OrganizationSettingHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organizationsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organizationsetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(organizationsetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(organizationsetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(organizationsetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(organizationsetting.DeletedBy)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(organizationsetting.Domains)
		}

		if ssoCert, exists := m.SSOCert(); exists {
			create = create.SetSSOCert(ssoCert)
		} else {
			create = create.SetSSOCert(organizationsetting.SSOCert)
		}

		if ssoEntrypoint, exists := m.SSOEntrypoint(); exists {
			create = create.SetSSOEntrypoint(ssoEntrypoint)
		} else {
			create = create.SetSSOEntrypoint(organizationsetting.SSOEntrypoint)
		}

		if ssoIssuer, exists := m.SSOIssuer(); exists {
			create = create.SetSSOIssuer(ssoIssuer)
		} else {
			create = create.SetSSOIssuer(organizationsetting.SSOIssuer)
		}

		if billingContact, exists := m.BillingContact(); exists {
			create = create.SetBillingContact(billingContact)
		} else {
			create = create.SetBillingContact(organizationsetting.BillingContact)
		}

		if billingEmail, exists := m.BillingEmail(); exists {
			create = create.SetBillingEmail(billingEmail)
		} else {
			create = create.SetBillingEmail(organizationsetting.BillingEmail)
		}

		if billingPhone, exists := m.BillingPhone(); exists {
			create = create.SetBillingPhone(billingPhone)
		} else {
			create = create.SetBillingPhone(organizationsetting.BillingPhone)
		}

		if billingAddress, exists := m.BillingAddress(); exists {
			create = create.SetBillingAddress(billingAddress)
		} else {
			create = create.SetBillingAddress(organizationsetting.BillingAddress)
		}

		if taxIdentifier, exists := m.TaxIdentifier(); exists {
			create = create.SetTaxIdentifier(taxIdentifier)
		} else {
			create = create.SetTaxIdentifier(organizationsetting.TaxIdentifier)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organizationsetting.Tags)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.OrganizationSettingHistory.Create()
		if tx != nil {
			create = tx.OrganizationSettingHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organizationsetting.CreatedAt).
			SetUpdatedAt(organizationsetting.UpdatedAt).
			SetCreatedBy(organizationsetting.CreatedBy).
			SetUpdatedBy(organizationsetting.UpdatedBy).
			SetDeletedAt(organizationsetting.DeletedAt).
			SetDeletedBy(organizationsetting.DeletedBy).
			SetDomains(organizationsetting.Domains).
			SetSSOCert(organizationsetting.SSOCert).
			SetSSOEntrypoint(organizationsetting.SSOEntrypoint).
			SetSSOIssuer(organizationsetting.SSOIssuer).
			SetBillingContact(organizationsetting.BillingContact).
			SetBillingEmail(organizationsetting.BillingEmail).
			SetBillingPhone(organizationsetting.BillingPhone).
			SetBillingAddress(organizationsetting.BillingAddress).
			SetTaxIdentifier(organizationsetting.TaxIdentifier).
			SetTags(organizationsetting.Tags).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *PasswordResetTokenMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.PasswordResetTokenHistory.Create()
	if tx != nil {
		create = tx.PasswordResetTokenHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if token, exists := m.Token(); exists {
		create = create.SetToken(token)
	}

	if ttl, exists := m.TTL(); exists {
		create = create.SetNillableTTL(&ttl)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if secret, exists := m.Secret(); exists {
		create = create.SetNillableSecret(&secret)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *PasswordResetTokenMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		passwordresettoken, err := client.PasswordResetToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.PasswordResetTokenHistory.Create()
		if tx != nil {
			create = tx.PasswordResetTokenHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(passwordresettoken.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(passwordresettoken.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(passwordresettoken.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(passwordresettoken.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(passwordresettoken.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(passwordresettoken.DeletedBy)
		}

		if token, exists := m.Token(); exists {
			create = create.SetToken(token)
		} else {
			create = create.SetToken(passwordresettoken.Token)
		}

		if ttl, exists := m.TTL(); exists {
			create = create.SetNillableTTL(&ttl)
		} else {
			create = create.SetNillableTTL(passwordresettoken.TTL)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(passwordresettoken.Email)
		}

		if secret, exists := m.Secret(); exists {
			create = create.SetNillableSecret(&secret)
		} else {
			create = create.SetNillableSecret(passwordresettoken.Secret)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *PasswordResetTokenMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		passwordresettoken, err := client.PasswordResetToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.PasswordResetTokenHistory.Create()
		if tx != nil {
			create = tx.PasswordResetTokenHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(passwordresettoken.CreatedAt).
			SetUpdatedAt(passwordresettoken.UpdatedAt).
			SetCreatedBy(passwordresettoken.CreatedBy).
			SetUpdatedBy(passwordresettoken.UpdatedBy).
			SetDeletedAt(passwordresettoken.DeletedAt).
			SetDeletedBy(passwordresettoken.DeletedBy).
			SetToken(passwordresettoken.Token).
			SetNillableTTL(passwordresettoken.TTL).
			SetEmail(passwordresettoken.Email).
			SetNillableSecret(passwordresettoken.Secret).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *PersonalAccessTokenMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.PersonalAccessTokenHistory.Create()
	if tx != nil {
		create = tx.PersonalAccessTokenHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if token, exists := m.Token(); exists {
		create = create.SetToken(token)
	}

	if abilities, exists := m.Abilities(); exists {
		create = create.SetAbilities(abilities)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetNillableExpiresAt(&expiresAt)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if lastUsedAt, exists := m.LastUsedAt(); exists {
		create = create.SetNillableLastUsedAt(&lastUsedAt)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *PersonalAccessTokenMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		personalaccesstoken, err := client.PersonalAccessToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.PersonalAccessTokenHistory.Create()
		if tx != nil {
			create = tx.PersonalAccessTokenHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(personalaccesstoken.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(personalaccesstoken.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(personalaccesstoken.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(personalaccesstoken.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(personalaccesstoken.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(personalaccesstoken.DeletedBy)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(personalaccesstoken.Name)
		}

		if token, exists := m.Token(); exists {
			create = create.SetToken(token)
		} else {
			create = create.SetToken(personalaccesstoken.Token)
		}

		if abilities, exists := m.Abilities(); exists {
			create = create.SetAbilities(abilities)
		} else {
			create = create.SetAbilities(personalaccesstoken.Abilities)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetNillableExpiresAt(&expiresAt)
		} else {
			create = create.SetNillableExpiresAt(personalaccesstoken.ExpiresAt)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(personalaccesstoken.Description)
		}

		if lastUsedAt, exists := m.LastUsedAt(); exists {
			create = create.SetNillableLastUsedAt(&lastUsedAt)
		} else {
			create = create.SetNillableLastUsedAt(personalaccesstoken.LastUsedAt)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *PersonalAccessTokenMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		personalaccesstoken, err := client.PersonalAccessToken.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.PersonalAccessTokenHistory.Create()
		if tx != nil {
			create = tx.PersonalAccessTokenHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(personalaccesstoken.CreatedAt).
			SetUpdatedAt(personalaccesstoken.UpdatedAt).
			SetCreatedBy(personalaccesstoken.CreatedBy).
			SetUpdatedBy(personalaccesstoken.UpdatedBy).
			SetDeletedAt(personalaccesstoken.DeletedAt).
			SetDeletedBy(personalaccesstoken.DeletedBy).
			SetName(personalaccesstoken.Name).
			SetToken(personalaccesstoken.Token).
			SetAbilities(personalaccesstoken.Abilities).
			SetNillableExpiresAt(personalaccesstoken.ExpiresAt).
			SetDescription(personalaccesstoken.Description).
			SetNillableLastUsedAt(personalaccesstoken.LastUsedAt).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *SessionMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.SessionHistory.Create()
	if tx != nil {
		create = tx.SessionHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if sessionToken, exists := m.SessionToken(); exists {
		create = create.SetSessionToken(sessionToken)
	}

	if issuedAt, exists := m.IssuedAt(); exists {
		create = create.SetIssuedAt(issuedAt)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetExpiresAt(expiresAt)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *SessionMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		session, err := client.Session.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.SessionHistory.Create()
		if tx != nil {
			create = tx.SessionHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(session.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(session.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(session.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(session.UpdatedBy)
		}

		if sessionToken, exists := m.SessionToken(); exists {
			create = create.SetSessionToken(sessionToken)
		} else {
			create = create.SetSessionToken(session.SessionToken)
		}

		if issuedAt, exists := m.IssuedAt(); exists {
			create = create.SetIssuedAt(issuedAt)
		} else {
			create = create.SetIssuedAt(session.IssuedAt)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetExpiresAt(expiresAt)
		} else {
			create = create.SetExpiresAt(session.ExpiresAt)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(session.OrganizationID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(session.UserID)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *SessionMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		session, err := client.Session.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.SessionHistory.Create()
		if tx != nil {
			create = tx.SessionHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(session.CreatedAt).
			SetUpdatedAt(session.UpdatedAt).
			SetCreatedBy(session.CreatedBy).
			SetUpdatedBy(session.UpdatedBy).
			SetSessionToken(session.SessionToken).
			SetIssuedAt(session.IssuedAt).
			SetExpiresAt(session.ExpiresAt).
			SetOrganizationID(session.OrganizationID).
			SetUserID(session.UserID).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.UserHistory.Create()
	if tx != nil {
		create = tx.UserHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if firstName, exists := m.FirstName(); exists {
		create = create.SetFirstName(firstName)
	}

	if lastName, exists := m.LastName(); exists {
		create = create.SetLastName(lastName)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if avatarLocalFile, exists := m.AvatarLocalFile(); exists {
		create = create.SetNillableAvatarLocalFile(&avatarLocalFile)
	}

	if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
		create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
	}

	if lastSeen, exists := m.LastSeen(); exists {
		create = create.SetNillableLastSeen(&lastSeen)
	}

	if password, exists := m.Password(); exists {
		create = create.SetNillablePassword(&password)
	}

	if sub, exists := m.Sub(); exists {
		create = create.SetSub(sub)
	}

	if oauth, exists := m.Oauth(); exists {
		create = create.SetOauth(oauth)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UserMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.UserHistory.Create()
		if tx != nil {
			create = tx.UserHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(user.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(user.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(user.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(user.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(user.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(user.DeletedBy)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(user.Email)
		}

		if firstName, exists := m.FirstName(); exists {
			create = create.SetFirstName(firstName)
		} else {
			create = create.SetFirstName(user.FirstName)
		}

		if lastName, exists := m.LastName(); exists {
			create = create.SetLastName(lastName)
		} else {
			create = create.SetLastName(user.LastName)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(user.DisplayName)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(user.AvatarRemoteURL)
		}

		if avatarLocalFile, exists := m.AvatarLocalFile(); exists {
			create = create.SetNillableAvatarLocalFile(&avatarLocalFile)
		} else {
			create = create.SetNillableAvatarLocalFile(user.AvatarLocalFile)
		}

		if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
			create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
		} else {
			create = create.SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt)
		}

		if lastSeen, exists := m.LastSeen(); exists {
			create = create.SetNillableLastSeen(&lastSeen)
		} else {
			create = create.SetNillableLastSeen(user.LastSeen)
		}

		if password, exists := m.Password(); exists {
			create = create.SetNillablePassword(&password)
		} else {
			create = create.SetNillablePassword(user.Password)
		}

		if sub, exists := m.Sub(); exists {
			create = create.SetSub(sub)
		} else {
			create = create.SetSub(user.Sub)
		}

		if oauth, exists := m.Oauth(); exists {
			create = create.SetOauth(oauth)
		} else {
			create = create.SetOauth(user.Oauth)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.UserHistory.Create()
		if tx != nil {
			create = tx.UserHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(user.CreatedAt).
			SetUpdatedAt(user.UpdatedAt).
			SetCreatedBy(user.CreatedBy).
			SetUpdatedBy(user.UpdatedBy).
			SetDeletedAt(user.DeletedAt).
			SetDeletedBy(user.DeletedBy).
			SetEmail(user.Email).
			SetFirstName(user.FirstName).
			SetLastName(user.LastName).
			SetDisplayName(user.DisplayName).
			SetNillableAvatarRemoteURL(user.AvatarRemoteURL).
			SetNillableAvatarLocalFile(user.AvatarLocalFile).
			SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt).
			SetNillableLastSeen(user.LastSeen).
			SetNillablePassword(user.Password).
			SetSub(user.Sub).
			SetOauth(user.Oauth).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.UserSettingHistory.Create()
	if tx != nil {
		create = tx.UserSettingHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if locked, exists := m.Locked(); exists {
		create = create.SetLocked(locked)
	}

	if silencedAt, exists := m.SilencedAt(); exists {
		create = create.SetNillableSilencedAt(&silencedAt)
	}

	if suspendedAt, exists := m.SuspendedAt(); exists {
		create = create.SetNillableSuspendedAt(&suspendedAt)
	}

	if recoveryCode, exists := m.RecoveryCode(); exists {
		create = create.SetNillableRecoveryCode(&recoveryCode)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if permissions, exists := m.Permissions(); exists {
		create = create.SetPermissions(permissions)
	}

	if emailConfirmed, exists := m.EmailConfirmed(); exists {
		create = create.SetEmailConfirmed(emailConfirmed)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UserSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.UserSettingHistory.Create()
		if tx != nil {
			create = tx.UserSettingHistory.Create()
		}
		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(usersetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(usersetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(usersetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(usersetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(usersetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(usersetting.DeletedBy)
		}

		if locked, exists := m.Locked(); exists {
			create = create.SetLocked(locked)
		} else {
			create = create.SetLocked(usersetting.Locked)
		}

		if silencedAt, exists := m.SilencedAt(); exists {
			create = create.SetNillableSilencedAt(&silencedAt)
		} else {
			create = create.SetNillableSilencedAt(usersetting.SilencedAt)
		}

		if suspendedAt, exists := m.SuspendedAt(); exists {
			create = create.SetNillableSuspendedAt(&suspendedAt)
		} else {
			create = create.SetNillableSuspendedAt(usersetting.SuspendedAt)
		}

		if recoveryCode, exists := m.RecoveryCode(); exists {
			create = create.SetNillableRecoveryCode(&recoveryCode)
		} else {
			create = create.SetNillableRecoveryCode(usersetting.RecoveryCode)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(usersetting.Status)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(usersetting.Role)
		}

		if permissions, exists := m.Permissions(); exists {
			create = create.SetPermissions(permissions)
		} else {
			create = create.SetPermissions(usersetting.Permissions)
		}

		if emailConfirmed, exists := m.EmailConfirmed(); exists {
			create = create.SetEmailConfirmed(emailConfirmed)
		} else {
			create = create.SetEmailConfirmed(usersetting.EmailConfirmed)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(usersetting.Tags)
		}

		_, err = create.Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return rollback(tx, fmt.Errorf("getting ids: %w", err))
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return rollback(tx, err)
		}

		create := client.UserSettingHistory.Create()
		if tx != nil {
			create = tx.UserSettingHistory.Create()
		}

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(usersetting.CreatedAt).
			SetUpdatedAt(usersetting.UpdatedAt).
			SetCreatedBy(usersetting.CreatedBy).
			SetUpdatedBy(usersetting.UpdatedBy).
			SetDeletedAt(usersetting.DeletedAt).
			SetDeletedBy(usersetting.DeletedBy).
			SetLocked(usersetting.Locked).
			SetNillableSilencedAt(usersetting.SilencedAt).
			SetNillableSuspendedAt(usersetting.SuspendedAt).
			SetNillableRecoveryCode(usersetting.RecoveryCode).
			SetStatus(usersetting.Status).
			SetRole(usersetting.Role).
			SetPermissions(usersetting.Permissions).
			SetEmailConfirmed(usersetting.EmailConfirmed).
			SetTags(usersetting.Tags).
			Save(ctx)
		if err != nil {
			rollback(tx, err)
		}
	}

	return nil
}
