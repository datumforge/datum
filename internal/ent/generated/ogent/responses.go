// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/datumforge/datum/internal/ent/generated"

func NewGroupCreate(e *generated.Group) *GroupCreate {
	if e == nil {
		return nil
	}
	var ret GroupCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupCreates(es []*generated.Group) []GroupCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupCreate, len(es))
	for i, e := range es {
		r[i] = NewGroupCreate(e).Elem()
	}
	return r
}

func (gr *GroupCreate) Elem() GroupCreate {
	if gr == nil {
		return GroupCreate{}
	}
	return *gr
}

func NewGroupList(e *generated.Group) *GroupList {
	if e == nil {
		return nil
	}
	var ret GroupList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupLists(es []*generated.Group) []GroupList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupList, len(es))
	for i, e := range es {
		r[i] = NewGroupList(e).Elem()
	}
	return r
}

func (gr *GroupList) Elem() GroupList {
	if gr == nil {
		return GroupList{}
	}
	return *gr
}

func NewGroupRead(e *generated.Group) *GroupRead {
	if e == nil {
		return nil
	}
	var ret GroupRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupReads(es []*generated.Group) []GroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupRead, len(es))
	for i, e := range es {
		r[i] = NewGroupRead(e).Elem()
	}
	return r
}

func (gr *GroupRead) Elem() GroupRead {
	if gr == nil {
		return GroupRead{}
	}
	return *gr
}

func NewGroupSettingsCreate(e *generated.GroupSettings) *GroupSettingsCreate {
	if e == nil {
		return nil
	}
	var ret GroupSettingsCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Visibility = GroupSettingsCreateVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsCreateJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsCreates(es []*generated.GroupSettings) []GroupSettingsCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsCreate, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsCreate(e).Elem()
	}
	return r
}

func (gs *GroupSettingsCreate) Elem() GroupSettingsCreate {
	if gs == nil {
		return GroupSettingsCreate{}
	}
	return *gs
}

func NewGroupSettingsList(e *generated.GroupSettings) *GroupSettingsList {
	if e == nil {
		return nil
	}
	var ret GroupSettingsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Visibility = GroupSettingsListVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsListJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsLists(es []*generated.GroupSettings) []GroupSettingsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsList, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsList(e).Elem()
	}
	return r
}

func (gs *GroupSettingsList) Elem() GroupSettingsList {
	if gs == nil {
		return GroupSettingsList{}
	}
	return *gs
}

func NewGroupSettingsRead(e *generated.GroupSettings) *GroupSettingsRead {
	if e == nil {
		return nil
	}
	var ret GroupSettingsRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Visibility = GroupSettingsReadVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsReadJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsReads(es []*generated.GroupSettings) []GroupSettingsRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsRead, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsRead(e).Elem()
	}
	return r
}

func (gs *GroupSettingsRead) Elem() GroupSettingsRead {
	if gs == nil {
		return GroupSettingsRead{}
	}
	return *gs
}

func NewGroupSettingsUpdate(e *generated.GroupSettings) *GroupSettingsUpdate {
	if e == nil {
		return nil
	}
	var ret GroupSettingsUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Visibility = GroupSettingsUpdateVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsUpdateJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsUpdates(es []*generated.GroupSettings) []GroupSettingsUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsUpdate, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsUpdate(e).Elem()
	}
	return r
}

func (gs *GroupSettingsUpdate) Elem() GroupSettingsUpdate {
	if gs == nil {
		return GroupSettingsUpdate{}
	}
	return *gs
}

func NewGroupSettingsGroupRead(e *generated.Group) *GroupSettingsGroupRead {
	if e == nil {
		return nil
	}
	var ret GroupSettingsGroupRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupSettingsGroupReads(es []*generated.Group) []GroupSettingsGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsGroupRead, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsGroupRead(e).Elem()
	}
	return r
}

func (gr *GroupSettingsGroupRead) Elem() GroupSettingsGroupRead {
	if gr == nil {
		return GroupSettingsGroupRead{}
	}
	return *gr
}

func NewGroupUpdate(e *generated.Group) *GroupUpdate {
	if e == nil {
		return nil
	}
	var ret GroupUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupUpdates(es []*generated.Group) []GroupUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupUpdate, len(es))
	for i, e := range es {
		r[i] = NewGroupUpdate(e).Elem()
	}
	return r
}

func (gr *GroupUpdate) Elem() GroupUpdate {
	if gr == nil {
		return GroupUpdate{}
	}
	return *gr
}

func NewGroupMembershipsList(e *generated.Membership) *GroupMembershipsList {
	if e == nil {
		return nil
	}
	var ret GroupMembershipsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewGroupMembershipsLists(es []*generated.Membership) []GroupMembershipsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupMembershipsList, len(es))
	for i, e := range es {
		r[i] = NewGroupMembershipsList(e).Elem()
	}
	return r
}

func (m *GroupMembershipsList) Elem() GroupMembershipsList {
	if m == nil {
		return GroupMembershipsList{}
	}
	return *m
}

func NewGroupSettingRead(e *generated.GroupSettings) *GroupSettingRead {
	if e == nil {
		return nil
	}
	var ret GroupSettingRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Visibility = GroupSettingReadVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingReadJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingReads(es []*generated.GroupSettings) []GroupSettingRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingRead, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingRead(e).Elem()
	}
	return r
}

func (gs *GroupSettingRead) Elem() GroupSettingRead {
	if gs == nil {
		return GroupSettingRead{}
	}
	return *gs
}

func NewGroupUsersList(e *generated.User) *GroupUsersList {
	if e == nil {
		return nil
	}
	var ret GroupUsersList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewGroupUsersLists(es []*generated.User) []GroupUsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupUsersList, len(es))
	for i, e := range es {
		r[i] = NewGroupUsersList(e).Elem()
	}
	return r
}

func (u *GroupUsersList) Elem() GroupUsersList {
	if u == nil {
		return GroupUsersList{}
	}
	return *u
}

func NewIntegrationCreate(e *generated.Integration) *IntegrationCreate {
	if e == nil {
		return nil
	}
	var ret IntegrationCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationCreates(es []*generated.Integration) []IntegrationCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationCreate, len(es))
	for i, e := range es {
		r[i] = NewIntegrationCreate(e).Elem()
	}
	return r
}

func (i *IntegrationCreate) Elem() IntegrationCreate {
	if i == nil {
		return IntegrationCreate{}
	}
	return *i
}

func NewIntegrationList(e *generated.Integration) *IntegrationList {
	if e == nil {
		return nil
	}
	var ret IntegrationList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationLists(es []*generated.Integration) []IntegrationList {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationList, len(es))
	for i, e := range es {
		r[i] = NewIntegrationList(e).Elem()
	}
	return r
}

func (i *IntegrationList) Elem() IntegrationList {
	if i == nil {
		return IntegrationList{}
	}
	return *i
}

func NewIntegrationRead(e *generated.Integration) *IntegrationRead {
	if e == nil {
		return nil
	}
	var ret IntegrationRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationReads(es []*generated.Integration) []IntegrationRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationRead, len(es))
	for i, e := range es {
		r[i] = NewIntegrationRead(e).Elem()
	}
	return r
}

func (i *IntegrationRead) Elem() IntegrationRead {
	if i == nil {
		return IntegrationRead{}
	}
	return *i
}

func NewIntegrationUpdate(e *generated.Integration) *IntegrationUpdate {
	if e == nil {
		return nil
	}
	var ret IntegrationUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationUpdates(es []*generated.Integration) []IntegrationUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationUpdate, len(es))
	for i, e := range es {
		r[i] = NewIntegrationUpdate(e).Elem()
	}
	return r
}

func (i *IntegrationUpdate) Elem() IntegrationUpdate {
	if i == nil {
		return IntegrationUpdate{}
	}
	return *i
}

func NewIntegrationOrganizationRead(e *generated.Organization) *IntegrationOrganizationRead {
	if e == nil {
		return nil
	}
	var ret IntegrationOrganizationRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	return &ret
}

func NewIntegrationOrganizationReads(es []*generated.Organization) []IntegrationOrganizationRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationOrganizationRead, len(es))
	for i, e := range es {
		r[i] = NewIntegrationOrganizationRead(e).Elem()
	}
	return r
}

func (o *IntegrationOrganizationRead) Elem() IntegrationOrganizationRead {
	if o == nil {
		return IntegrationOrganizationRead{}
	}
	return *o
}

func NewMembershipCreate(e *generated.Membership) *MembershipCreate {
	if e == nil {
		return nil
	}
	var ret MembershipCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewMembershipCreates(es []*generated.Membership) []MembershipCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipCreate, len(es))
	for i, e := range es {
		r[i] = NewMembershipCreate(e).Elem()
	}
	return r
}

func (m *MembershipCreate) Elem() MembershipCreate {
	if m == nil {
		return MembershipCreate{}
	}
	return *m
}

func NewMembershipList(e *generated.Membership) *MembershipList {
	if e == nil {
		return nil
	}
	var ret MembershipList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewMembershipLists(es []*generated.Membership) []MembershipList {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipList, len(es))
	for i, e := range es {
		r[i] = NewMembershipList(e).Elem()
	}
	return r
}

func (m *MembershipList) Elem() MembershipList {
	if m == nil {
		return MembershipList{}
	}
	return *m
}

func NewMembershipRead(e *generated.Membership) *MembershipRead {
	if e == nil {
		return nil
	}
	var ret MembershipRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewMembershipReads(es []*generated.Membership) []MembershipRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipRead, len(es))
	for i, e := range es {
		r[i] = NewMembershipRead(e).Elem()
	}
	return r
}

func (m *MembershipRead) Elem() MembershipRead {
	if m == nil {
		return MembershipRead{}
	}
	return *m
}

func NewMembershipUpdate(e *generated.Membership) *MembershipUpdate {
	if e == nil {
		return nil
	}
	var ret MembershipUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewMembershipUpdates(es []*generated.Membership) []MembershipUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipUpdate, len(es))
	for i, e := range es {
		r[i] = NewMembershipUpdate(e).Elem()
	}
	return r
}

func (m *MembershipUpdate) Elem() MembershipUpdate {
	if m == nil {
		return MembershipUpdate{}
	}
	return *m
}

func NewMembershipGroupRead(e *generated.Group) *MembershipGroupRead {
	if e == nil {
		return nil
	}
	var ret MembershipGroupRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewMembershipGroupReads(es []*generated.Group) []MembershipGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipGroupRead, len(es))
	for i, e := range es {
		r[i] = NewMembershipGroupRead(e).Elem()
	}
	return r
}

func (gr *MembershipGroupRead) Elem() MembershipGroupRead {
	if gr == nil {
		return MembershipGroupRead{}
	}
	return *gr
}

func NewMembershipOrganizationRead(e *generated.Organization) *MembershipOrganizationRead {
	if e == nil {
		return nil
	}
	var ret MembershipOrganizationRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	return &ret
}

func NewMembershipOrganizationReads(es []*generated.Organization) []MembershipOrganizationRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipOrganizationRead, len(es))
	for i, e := range es {
		r[i] = NewMembershipOrganizationRead(e).Elem()
	}
	return r
}

func (o *MembershipOrganizationRead) Elem() MembershipOrganizationRead {
	if o == nil {
		return MembershipOrganizationRead{}
	}
	return *o
}

func NewMembershipUserRead(e *generated.User) *MembershipUserRead {
	if e == nil {
		return nil
	}
	var ret MembershipUserRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewMembershipUserReads(es []*generated.User) []MembershipUserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MembershipUserRead, len(es))
	for i, e := range es {
		r[i] = NewMembershipUserRead(e).Elem()
	}
	return r
}

func (u *MembershipUserRead) Elem() MembershipUserRead {
	if u == nil {
		return MembershipUserRead{}
	}
	return *u
}

func NewOrganizationCreate(e *generated.Organization) *OrganizationCreate {
	if e == nil {
		return nil
	}
	var ret OrganizationCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	return &ret
}

func NewOrganizationCreates(es []*generated.Organization) []OrganizationCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationCreate, len(es))
	for i, e := range es {
		r[i] = NewOrganizationCreate(e).Elem()
	}
	return r
}

func (o *OrganizationCreate) Elem() OrganizationCreate {
	if o == nil {
		return OrganizationCreate{}
	}
	return *o
}

func NewOrganizationList(e *generated.Organization) *OrganizationList {
	if e == nil {
		return nil
	}
	var ret OrganizationList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	return &ret
}

func NewOrganizationLists(es []*generated.Organization) []OrganizationList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationList(e).Elem()
	}
	return r
}

func (o *OrganizationList) Elem() OrganizationList {
	if o == nil {
		return OrganizationList{}
	}
	return *o
}

func NewOrganizationRead(e *generated.Organization) *OrganizationRead {
	if e == nil {
		return nil
	}
	var ret OrganizationRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	return &ret
}

func NewOrganizationReads(es []*generated.Organization) []OrganizationRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationRead, len(es))
	for i, e := range es {
		r[i] = NewOrganizationRead(e).Elem()
	}
	return r
}

func (o *OrganizationRead) Elem() OrganizationRead {
	if o == nil {
		return OrganizationRead{}
	}
	return *o
}

func NewOrganizationUpdate(e *generated.Organization) *OrganizationUpdate {
	if e == nil {
		return nil
	}
	var ret OrganizationUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	return &ret
}

func NewOrganizationUpdates(es []*generated.Organization) []OrganizationUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationUpdate, len(es))
	for i, e := range es {
		r[i] = NewOrganizationUpdate(e).Elem()
	}
	return r
}

func (o *OrganizationUpdate) Elem() OrganizationUpdate {
	if o == nil {
		return OrganizationUpdate{}
	}
	return *o
}

func NewOrganizationIntegrationsList(e *generated.Integration) *OrganizationIntegrationsList {
	if e == nil {
		return nil
	}
	var ret OrganizationIntegrationsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewOrganizationIntegrationsLists(es []*generated.Integration) []OrganizationIntegrationsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationIntegrationsList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationIntegrationsList(e).Elem()
	}
	return r
}

func (i *OrganizationIntegrationsList) Elem() OrganizationIntegrationsList {
	if i == nil {
		return OrganizationIntegrationsList{}
	}
	return *i
}

func NewOrganizationMembershipsList(e *generated.Membership) *OrganizationMembershipsList {
	if e == nil {
		return nil
	}
	var ret OrganizationMembershipsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewOrganizationMembershipsLists(es []*generated.Membership) []OrganizationMembershipsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationMembershipsList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationMembershipsList(e).Elem()
	}
	return r
}

func (m *OrganizationMembershipsList) Elem() OrganizationMembershipsList {
	if m == nil {
		return OrganizationMembershipsList{}
	}
	return *m
}

func NewSessionCreate(e *generated.Session) *SessionCreate {
	if e == nil {
		return nil
	}
	var ret SessionCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Type = SessionCreateType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionCreates(es []*generated.Session) []SessionCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionCreate, len(es))
	for i, e := range es {
		r[i] = NewSessionCreate(e).Elem()
	}
	return r
}

func (s *SessionCreate) Elem() SessionCreate {
	if s == nil {
		return SessionCreate{}
	}
	return *s
}

func NewSessionList(e *generated.Session) *SessionList {
	if e == nil {
		return nil
	}
	var ret SessionList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Type = SessionListType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionLists(es []*generated.Session) []SessionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionList, len(es))
	for i, e := range es {
		r[i] = NewSessionList(e).Elem()
	}
	return r
}

func (s *SessionList) Elem() SessionList {
	if s == nil {
		return SessionList{}
	}
	return *s
}

func NewSessionRead(e *generated.Session) *SessionRead {
	if e == nil {
		return nil
	}
	var ret SessionRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Type = SessionReadType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionReads(es []*generated.Session) []SessionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionRead, len(es))
	for i, e := range es {
		r[i] = NewSessionRead(e).Elem()
	}
	return r
}

func (s *SessionRead) Elem() SessionRead {
	if s == nil {
		return SessionRead{}
	}
	return *s
}

func NewSessionUpdate(e *generated.Session) *SessionUpdate {
	if e == nil {
		return nil
	}
	var ret SessionUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Type = SessionUpdateType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionUpdates(es []*generated.Session) []SessionUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionUpdate, len(es))
	for i, e := range es {
		r[i] = NewSessionUpdate(e).Elem()
	}
	return r
}

func (s *SessionUpdate) Elem() SessionUpdate {
	if s == nil {
		return SessionUpdate{}
	}
	return *s
}

func NewSessionUsersRead(e *generated.User) *SessionUsersRead {
	if e == nil {
		return nil
	}
	var ret SessionUsersRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewSessionUsersReads(es []*generated.User) []SessionUsersRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionUsersRead, len(es))
	for i, e := range es {
		r[i] = NewSessionUsersRead(e).Elem()
	}
	return r
}

func (u *SessionUsersRead) Elem() SessionUsersRead {
	if u == nil {
		return SessionUsersRead{}
	}
	return *u
}

func NewUserCreate(e *generated.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserCreates(es []*generated.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *generated.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserLists(es []*generated.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *generated.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserReads(es []*generated.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *generated.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserUpdates(es []*generated.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}

func NewUserGroupsList(e *generated.Group) *UserGroupsList {
	if e == nil {
		return nil
	}
	var ret UserGroupsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewUserGroupsLists(es []*generated.Group) []UserGroupsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserGroupsList, len(es))
	for i, e := range es {
		r[i] = NewUserGroupsList(e).Elem()
	}
	return r
}

func (gr *UserGroupsList) Elem() UserGroupsList {
	if gr == nil {
		return UserGroupsList{}
	}
	return *gr
}

func NewUserMembershipsList(e *generated.Membership) *UserMembershipsList {
	if e == nil {
		return nil
	}
	var ret UserMembershipsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Current = e.Current
	return &ret
}

func NewUserMembershipsLists(es []*generated.Membership) []UserMembershipsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserMembershipsList, len(es))
	for i, e := range es {
		r[i] = NewUserMembershipsList(e).Elem()
	}
	return r
}

func (m *UserMembershipsList) Elem() UserMembershipsList {
	if m == nil {
		return UserMembershipsList{}
	}
	return *m
}

func NewUserSessionsList(e *generated.Session) *UserSessionsList {
	if e == nil {
		return nil
	}
	var ret UserSessionsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptUUID(e.CreatedBy)
	ret.UpdatedBy = NewOptUUID(e.UpdatedBy)
	ret.Type = UserSessionsListType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewUserSessionsLists(es []*generated.Session) []UserSessionsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserSessionsList, len(es))
	for i, e := range es {
		r[i] = NewUserSessionsList(e).Elem()
	}
	return r
}

func (s *UserSessionsList) Elem() UserSessionsList {
	if s == nil {
		return UserSessionsList{}
	}
	return *s
}
