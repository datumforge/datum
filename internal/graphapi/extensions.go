package graphapi

import (
	"context"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/datumforge/datum/pkg/auth"
	"github.com/datumforge/datum/pkg/middleware/echocontext"
	"github.com/datumforge/datum/pkg/sessions"
	echo "github.com/datumforge/echox"
)

const (
	AuthExtensionKey          = "auth"
	ServerLatencyExtensionKey = "server_latency"
	TraceExtensionKey         = "trace_id"
)

type Auth struct {
	AuthenticationType     auth.AuthenticationType `json:"authentication_type"`
	AuthorizedOrganization string                  `json:"authorized_organization"`
	AccessToken            string                  `json:"access_token"`
	RefreshToken           string                  `json:"refresh_token"`
	SessionID              string                  `json:"session_id"`
}

// AddAllExtensions adds all the extensions to the server including auth, latency and trace
func AddAllExtensions(h *handler.Server) {
	// add the auth extension
	authExtension(h)
	// add the latency extension
	latencyExtension(h)
	// add the trace extension
	traceExtension(h)
}

func authExtension(h *handler.Server) {
	h.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {
		resp := next(ctx)

		resp = initExtensionResponse(resp)

		resp.Extensions[AuthExtensionKey] = getAuthData(ctx)

		return resp
	})
}

func latencyExtension(h *handler.Server) {
	h.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {
		start := time.Now()
		resp := next(ctx)
		latency := time.Since(start).String()

		resp = initExtensionResponse(resp)

		resp.Extensions[ServerLatencyExtensionKey] = latency

		return resp
	})
}

func traceExtension(h *handler.Server) {
	h.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {
		resp := next(ctx)

		traceID := getRequestID(ctx)

		resp = initExtensionResponse(resp)

		resp.Extensions[TraceExtensionKey] = traceID

		return resp
	})
}

// initExtensionResponse initializes the extensions map in the response to avoid nil pointer panics
func initExtensionResponse(resp *graphql.Response) *graphql.Response {
	if resp.Extensions == nil {
		resp.Extensions = make(map[string]interface{})
	}

	return resp
}

// getRequestID retrieves the trace request id from the context
// if the echo context is not available an empty string is returned
func getRequestID(ctx context.Context) string {
	c, err := echocontext.EchoContextFromContext(ctx)
	if err != nil {
		return ""
	}

	requestID := c.Request().Header.Get(echo.HeaderXRequestID) // request-id generated by reverse-proxy
	if requestID == "" {
		// missed request-id from proxy, got generated one by middleware.RequestID()
		requestID = c.Response().Header().Get(echo.HeaderXRequestID)
	}

	return requestID
}

// getAuthData retrieves the auth data from the context if available
// all errors are ignored because the auth data is optional
func getAuthData(ctx context.Context) Auth {
	at, _ := auth.GetAccessTokenContext(ctx)
	rt, _ := auth.GetRefreshTokenContext(ctx)
	session, _ := sessions.SessionToken(ctx)
	auth, _ := auth.GetAuthenticatedUserContext(ctx)

	return Auth{
		AuthenticationType:     auth.AuthenticationType,
		AuthorizedOrganization: auth.OrganizationID,
		AccessToken:            at,
		RefreshToken:           rt,
		SessionID:              session,
	}
}
