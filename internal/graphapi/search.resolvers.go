package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/datumforge/datum/internal/ent/generated"
)

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string) (*GlobalSearchResultConnection, error) {
	orgResults := make(chan searchResult[[]*generated.Organization])
	go searchOrganizations(ctx, query, orgResults)

	groupResults := make(chan searchResult[[]*generated.Group])
	go searchGroups(ctx, query, groupResults)

	userResults := make(chan searchResult[[]*generated.User])
	go searchUsers(ctx, query, userResults)

	subscriberResults := make(chan searchResult[[]*generated.Subscriber])
	go searchSubscriber(ctx, query, subscriberResults)

	// Wait for all results to be returned
	// first check for errors
	or := <-orgResults
	if or.err != nil {
		return nil, or.err
	}

	gr := <-groupResults
	if gr.err != nil {
		return nil, gr.err
	}

	ur := <-userResults
	if ur.err != nil {
		return nil, ur.err
	}

	sr := <-subscriberResults
	if sr.err != nil {
		return nil, sr.err
	}

	// return the results
	return &GlobalSearchResultConnection{
		Nodes: []GlobalSearchResult{
			OrganizationSearchResult{
				Organizations: or.result,
			},
			GroupSearchResult{
				Groups: gr.result,
			},
			UserSearchResult{
				Users: ur.result,
			},
			SubscriberSearchResult{
				Subscribers: sr.result,
			},
		},
	}, nil
}
