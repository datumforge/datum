// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package testclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/datumforge/datum/internal/ent/generated/session"
)

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	CreatedAt      *time.Time `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *int64     `json:"createdBy,omitempty"`
	UpdatedBy      *int64     `json:"updatedBy,omitempty"`
	Kind           string     `json:"kind"`
	Description    *string    `json:"description,omitempty"`
	SecretName     string     `json:"secretName"`
	OrganizationID string     `json:"organizationID"`
}

// CreateMembershipInput is used for create Membership object.
// Input was generated by ent.
type CreateMembershipInput struct {
	CreatedAt      *time.Time `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *int64     `json:"createdBy,omitempty"`
	UpdatedBy      *int64     `json:"updatedBy,omitempty"`
	Current        *bool      `json:"current,omitempty"`
	OrganizationID string     `json:"organizationID"`
	UserID         string     `json:"userID"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	CreatedAt      *time.Time `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *int64     `json:"createdBy,omitempty"`
	UpdatedBy      *int64     `json:"updatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	MembershipIDs  []string   `json:"membershipIDs,omitempty"`
	IntegrationIDs []string   `json:"integrationIDs,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *int64     `json:"createdBy,omitempty"`
	UpdatedBy *int64     `json:"updatedBy,omitempty"`
	Email     string     `json:"email"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// The time the user was silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was silenced
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// local Actor password recovery code generated during account creation
	RecoveryCode  *string  `json:"recoveryCode,omitempty"`
	MembershipIDs []string `json:"membershipIDs,omitempty"`
	SessionIDs    []string `json:"sessionIDs,omitempty"`
}

type Integration struct {
	ID           string       `json:"id"`
	CreatedAt    time.Time    `json:"createdAt"`
	UpdatedAt    time.Time    `json:"updatedAt"`
	CreatedBy    *int64       `json:"createdBy,omitempty"`
	UpdatedBy    *int64       `json:"updatedBy,omitempty"`
	Kind         string       `json:"kind"`
	Description  *string      `json:"description,omitempty"`
	SecretName   string       `json:"secretName"`
	Organization Organization `json:"organization"`
}

func (Integration) IsNode() {}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy       *int64  `json:"createdBy,omitempty"`
	CreatedByNeq    *int64  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int64 `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int64 `json:"createdByNotIn,omitempty"`
	CreatedByGt     *int64  `json:"createdByGT,omitempty"`
	CreatedByGte    *int64  `json:"createdByGTE,omitempty"`
	CreatedByLt     *int64  `json:"createdByLT,omitempty"`
	CreatedByLte    *int64  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  *bool   `json:"createdByIsNil,omitempty"`
	CreatedByNotNil *bool   `json:"createdByNotNil,omitempty"`
	// updated_by field predicates
	UpdatedBy       *int64  `json:"updatedBy,omitempty"`
	UpdatedByNeq    *int64  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int64 `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int64 `json:"updatedByNotIn,omitempty"`
	UpdatedByGt     *int64  `json:"updatedByGT,omitempty"`
	UpdatedByGte    *int64  `json:"updatedByGTE,omitempty"`
	UpdatedByLt     *int64  `json:"updatedByLT,omitempty"`
	UpdatedByLte    *int64  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  *bool   `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil *bool   `json:"updatedByNotNil,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

type Membership struct {
	ID           string       `json:"id"`
	CreatedAt    time.Time    `json:"createdAt"`
	UpdatedAt    time.Time    `json:"updatedAt"`
	CreatedBy    *int64       `json:"createdBy,omitempty"`
	UpdatedBy    *int64       `json:"updatedBy,omitempty"`
	Current      bool         `json:"current"`
	Organization Organization `json:"organization"`
	User         User         `json:"user"`
}

func (Membership) IsNode() {}

// Return response for createMembership mutation
type MembershipCreatePayload struct {
	// Created membership
	Membership Membership `json:"membership"`
}

// Return response for deleteMembership mutation
type MembershipDeletePayload struct {
	// Deleted membership ID
	DeletedID string `json:"deletedID"`
}

// Return response for updateMembership mutation
type MembershipUpdatePayload struct {
	// Updated membership
	Membership Membership `json:"membership"`
}

// MembershipWhereInput is used for filtering Membership objects.
// Input was generated by ent.
type MembershipWhereInput struct {
	Not *MembershipWhereInput   `json:"not,omitempty"`
	And []*MembershipWhereInput `json:"and,omitempty"`
	Or  []*MembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy       *int64  `json:"createdBy,omitempty"`
	CreatedByNeq    *int64  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int64 `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int64 `json:"createdByNotIn,omitempty"`
	CreatedByGt     *int64  `json:"createdByGT,omitempty"`
	CreatedByGte    *int64  `json:"createdByGTE,omitempty"`
	CreatedByLt     *int64  `json:"createdByLT,omitempty"`
	CreatedByLte    *int64  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  *bool   `json:"createdByIsNil,omitempty"`
	CreatedByNotNil *bool   `json:"createdByNotNil,omitempty"`
	// updated_by field predicates
	UpdatedBy       *int64  `json:"updatedBy,omitempty"`
	UpdatedByNeq    *int64  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int64 `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int64 `json:"updatedByNotIn,omitempty"`
	UpdatedByGt     *int64  `json:"updatedByGT,omitempty"`
	UpdatedByGte    *int64  `json:"updatedByGTE,omitempty"`
	UpdatedByLt     *int64  `json:"updatedByLT,omitempty"`
	UpdatedByLte    *int64  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  *bool   `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil *bool   `json:"updatedByNotNil,omitempty"`
	// current field predicates
	Current    *bool `json:"current,omitempty"`
	CurrentNeq *bool `json:"currentNEQ,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

type Organization struct {
	ID           string         `json:"id"`
	CreatedAt    time.Time      `json:"createdAt"`
	UpdatedAt    time.Time      `json:"updatedAt"`
	CreatedBy    *int64         `json:"createdBy,omitempty"`
	UpdatedBy    *int64         `json:"updatedBy,omitempty"`
	Name         string         `json:"name"`
	Memberships  []*Membership  `json:"memberships,omitempty"`
	Integrations []*Integration `json:"integrations,omitempty"`
}

func (Organization) IsNode() {}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy       *int64  `json:"createdBy,omitempty"`
	CreatedByNeq    *int64  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int64 `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int64 `json:"createdByNotIn,omitempty"`
	CreatedByGt     *int64  `json:"createdByGT,omitempty"`
	CreatedByGte    *int64  `json:"createdByGTE,omitempty"`
	CreatedByLt     *int64  `json:"createdByLT,omitempty"`
	CreatedByLte    *int64  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  *bool   `json:"createdByIsNil,omitempty"`
	CreatedByNotNil *bool   `json:"createdByNotNil,omitempty"`
	// updated_by field predicates
	UpdatedBy       *int64  `json:"updatedBy,omitempty"`
	UpdatedByNeq    *int64  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int64 `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int64 `json:"updatedByNotIn,omitempty"`
	UpdatedByGt     *int64  `json:"updatedByGT,omitempty"`
	UpdatedByGte    *int64  `json:"updatedByGTE,omitempty"`
	UpdatedByLt     *int64  `json:"updatedByLT,omitempty"`
	UpdatedByLte    *int64  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  *bool   `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil *bool   `json:"updatedByNotNil,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// memberships edge predicates
	HasMemberships     *bool                   `json:"hasMemberships,omitempty"`
	HasMembershipsWith []*MembershipWhereInput `json:"hasMembershipsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type Session struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *int64    `json:"createdBy,omitempty"`
	UpdatedBy *int64    `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token string `json:"token"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chornological order. The current IP is the first item in the slice
	Ips string `json:"ips"`
	// Sessions belong to users
	Users *User `json:"users,omitempty"`
}

func (Session) IsNode() {}

// SessionWhereInput is used for filtering Session objects.
// Input was generated by ent.
type SessionWhereInput struct {
	Not *SessionWhereInput   `json:"not,omitempty"`
	And []*SessionWhereInput `json:"and,omitempty"`
	Or  []*SessionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy       *int64  `json:"createdBy,omitempty"`
	CreatedByNeq    *int64  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int64 `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int64 `json:"createdByNotIn,omitempty"`
	CreatedByGt     *int64  `json:"createdByGT,omitempty"`
	CreatedByGte    *int64  `json:"createdByGTE,omitempty"`
	CreatedByLt     *int64  `json:"createdByLT,omitempty"`
	CreatedByLte    *int64  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  *bool   `json:"createdByIsNil,omitempty"`
	CreatedByNotNil *bool   `json:"createdByNotNil,omitempty"`
	// updated_by field predicates
	UpdatedBy       *int64  `json:"updatedBy,omitempty"`
	UpdatedByNeq    *int64  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int64 `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int64 `json:"updatedByNotIn,omitempty"`
	UpdatedByGt     *int64  `json:"updatedByGT,omitempty"`
	UpdatedByGte    *int64  `json:"updatedByGTE,omitempty"`
	UpdatedByLt     *int64  `json:"updatedByLT,omitempty"`
	UpdatedByLte    *int64  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  *bool   `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil *bool   `json:"updatedByNotNil,omitempty"`
	// type field predicates
	Type      *session.Type  `json:"type,omitempty"`
	TypeNeq   *session.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []session.Type `json:"typeIn,omitempty"`
	TypeNotIn []session.Type `json:"typeNotIn,omitempty"`
	// disabled field predicates
	Disabled    *bool `json:"disabled,omitempty"`
	DisabledNeq *bool `json:"disabledNEQ,omitempty"`
	// token field predicates
	Token             *string  `json:"token,omitempty"`
	TokenNeq          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGt           *string  `json:"tokenGT,omitempty"`
	TokenGte          *string  `json:"tokenGTE,omitempty"`
	TokenLt           *string  `json:"tokenLT,omitempty"`
	TokenLte          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`
	// user_agent field predicates
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNeq          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGt           *string  `json:"userAgentGT,omitempty"`
	UserAgentGte          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLt           *string  `json:"userAgentLT,omitempty"`
	UserAgentLte          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentIsNil        *bool    `json:"userAgentIsNil,omitempty"`
	UserAgentNotNil       *bool    `json:"userAgentNotNil,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`
	// ips field predicates
	Ips             *string  `json:"ips,omitempty"`
	IpsNeq          *string  `json:"ipsNEQ,omitempty"`
	IpsIn           []string `json:"ipsIn,omitempty"`
	IpsNotIn        []string `json:"ipsNotIn,omitempty"`
	IpsGt           *string  `json:"ipsGT,omitempty"`
	IpsGte          *string  `json:"ipsGTE,omitempty"`
	IpsLt           *string  `json:"ipsLT,omitempty"`
	IpsLte          *string  `json:"ipsLTE,omitempty"`
	IpsContains     *string  `json:"ipsContains,omitempty"`
	IpsHasPrefix    *string  `json:"ipsHasPrefix,omitempty"`
	IpsHasSuffix    *string  `json:"ipsHasSuffix,omitempty"`
	IpsEqualFold    *string  `json:"ipsEqualFold,omitempty"`
	IpsContainsFold *string  `json:"ipsContainsFold,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
	CreatedBy        *int64     `json:"createdBy,omitempty"`
	ClearCreatedBy   *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy        *int64     `json:"updatedBy,omitempty"`
	ClearUpdatedBy   *bool      `json:"clearUpdatedBy,omitempty"`
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	OrganizationID   *string    `json:"organizationID,omitempty"`
}

// UpdateMembershipInput is used for update Membership object.
// Input was generated by ent.
type UpdateMembershipInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *int64     `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *int64     `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Current        *bool      `json:"current,omitempty"`
	OrganizationID *string    `json:"organizationID,omitempty"`
	UserID         *string    `json:"userID,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	UpdatedAt            *time.Time `json:"updatedAt,omitempty"`
	CreatedBy            *int64     `json:"createdBy,omitempty"`
	ClearCreatedBy       *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy            *int64     `json:"updatedBy,omitempty"`
	ClearUpdatedBy       *bool      `json:"clearUpdatedBy,omitempty"`
	Name                 *string    `json:"name,omitempty"`
	AddMembershipIDs     []string   `json:"addMembershipIDs,omitempty"`
	RemoveMembershipIDs  []string   `json:"removeMembershipIDs,omitempty"`
	ClearMemberships     *bool      `json:"clearMemberships,omitempty"`
	AddIntegrationIDs    []string   `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string   `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool      `json:"clearIntegrations,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *int64     `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *int64     `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Email          *string    `json:"email,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile      *string `json:"avatarLocalFile,omitempty"`
	ClearAvatarLocalFile *bool   `json:"clearAvatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// The time the user was silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was silenced
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// local Actor password recovery code generated during account creation
	RecoveryCode        *string  `json:"recoveryCode,omitempty"`
	ClearRecoveryCode   *bool    `json:"clearRecoveryCode,omitempty"`
	AddMembershipIDs    []string `json:"addMembershipIDs,omitempty"`
	RemoveMembershipIDs []string `json:"removeMembershipIDs,omitempty"`
	ClearMemberships    *bool    `json:"clearMemberships,omitempty"`
	AddSessionIDs       []string `json:"addSessionIDs,omitempty"`
	RemoveSessionIDs    []string `json:"removeSessionIDs,omitempty"`
	ClearSessions       *bool    `json:"clearSessions,omitempty"`
}

type User struct {
	ID        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *int64    `json:"createdBy,omitempty"`
	UpdatedBy *int64    `json:"updatedBy,omitempty"`
	Email     string    `json:"email"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// The time the user was silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was silenced
	SuspendedAt *time.Time    `json:"suspendedAt,omitempty"`
	Memberships []*Membership `json:"memberships,omitempty"`
	Sessions    []*Session    `json:"sessions,omitempty"`
}

func (User) IsNode() {}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *string  `json:"id,omitempty"`
	IDNeq   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGt    *string  `json:"idGT,omitempty"`
	IDGte   *string  `json:"idGTE,omitempty"`
	IDLt    *string  `json:"idLT,omitempty"`
	IDLte   *string  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy       *int64  `json:"createdBy,omitempty"`
	CreatedByNeq    *int64  `json:"createdByNEQ,omitempty"`
	CreatedByIn     []int64 `json:"createdByIn,omitempty"`
	CreatedByNotIn  []int64 `json:"createdByNotIn,omitempty"`
	CreatedByGt     *int64  `json:"createdByGT,omitempty"`
	CreatedByGte    *int64  `json:"createdByGTE,omitempty"`
	CreatedByLt     *int64  `json:"createdByLT,omitempty"`
	CreatedByLte    *int64  `json:"createdByLTE,omitempty"`
	CreatedByIsNil  *bool   `json:"createdByIsNil,omitempty"`
	CreatedByNotNil *bool   `json:"createdByNotNil,omitempty"`
	// updated_by field predicates
	UpdatedBy       *int64  `json:"updatedBy,omitempty"`
	UpdatedByNeq    *int64  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int64 `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int64 `json:"updatedByNotIn,omitempty"`
	UpdatedByGt     *int64  `json:"updatedByGT,omitempty"`
	UpdatedByGte    *int64  `json:"updatedByGTE,omitempty"`
	UpdatedByLt     *int64  `json:"updatedByLT,omitempty"`
	UpdatedByLte    *int64  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  *bool   `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil *bool   `json:"updatedByNotNil,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// memberships edge predicates
	HasMemberships     *bool                   `json:"hasMemberships,omitempty"`
	HasMembershipsWith []*MembershipWhereInput `json:"hasMembershipsWith,omitempty"`
	// sessions edge predicates
	HasSessions     *bool                `json:"hasSessions,omitempty"`
	HasSessionsWith []*SessionWhereInput `json:"hasSessionsWith,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
